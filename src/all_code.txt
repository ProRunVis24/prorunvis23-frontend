===== ./ReportWebVitals.js =====
/**
 * Function to measure and report web-vital-values.
 * Important metrics for a good user experience.
 * @param {Function} onPerfEntry - A callback function that gets called to report measured performance.
 * */
const ReportWebVitals = onPerfEntry => {
    // Checks if callback function was provided and if it is a function.
    if (onPerfEntry && onPerfEntry instanceof Function) {
        // Loads in web-vitals module dynamically
        import('web-vitals').then(({getCLS, getFID, getFCP, getLCP, getTTFB}) => {
            // Calls the different web-vitals-functions and passes on the callback function.
            // Cumulative Layout Shift (CLS) measures stability of the layout.
            getCLS(onPerfEntry);
            // First Input Delay (FID) measures the time it takes the application to react after provided user input.
            getFID(onPerfEntry);
            // First Contentful Paint (FCP) measures the time before the first sign of content is loaded in.
            getFCP(onPerfEntry);
            // Largest Contentful Paint (LCP) measures loading time of biggest content.
            getLCP(onPerfEntry);
            // Time to First Byte (TTFB) measures the time until the first byte is received.
            getTTFB(onPerfEntry);
        });
    }
};

export default ReportWebVitals; // Export reportWebVitals function.
===== ./Css/JsonViewer.css =====
.json-viewer {
flex: 1;               /* fill parent vertical space if in a column layout */
  overflow-y: auto;      /* user can scroll inside when JSON is large */
  background-color: #222;
  color: #fff;
  min-height: 0;
}



.download-button {
  margin-top: 10px;
  padding: 10px 15px;
  background-color: #2196F3;
  color: #fff;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
.download-button:hover {
  background-color: #0b7dda;
}===== ./Css/Editor.css =====
===== ./Css/App.css =====
/* GLOBAL RESETS + SIZING */
html,
body,
#root {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  font-family: "Roboto", sans-serif;

  /* Dark gradient background for a futuristic vibe */
  background: radial-gradient(circle at top left, #1a1a2e 0%, #0f0f1f 100%);
  color: #E8F5FF; /* Softer white-cyan text for a neon aesthetic */
}

/* App container: top-level */
.App {
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100vh;
  overflow: hidden; /* Hide overflow beyond container */
}

/* NAVBAR */
.nav {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  background: linear-gradient(90deg, #15152b, #242447);
  height: 60px;
  padding: 0 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
  z-index: 2;
}

.nav--icon {
  height: 42px;
  margin-right: 15px;
}

/* Logo text */
.nav--logo_text {
  margin-right: auto;
  font-weight: 700;
  font-size: 1.3rem;
  color: #00ffd1; /* Neon teal accent */
}

/* Title or additional text (currently empty) */
.nav--title {
  color: #a7f3d0;
  font-weight: 400;
  margin-right: 20px;
  font-size: 1rem;
}

/* Help button */
.nav--help-button {
  background-color: #00ffd1;
  color: #000;
  border: 1px solid #25ffe0;
  border-radius: 20px;
  padding: 8px 20px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.25s ease;
}
.nav--help-button:hover {
  background-color: #25ffe0;
}

/* CONTENT: columns container */
.content {
  flex: 1;
  display: flex;
  flex-direction: row;
  height: calc(100% - 60px);
  position: relative;
}

/* Left container base styles */
.left-container {
  flex: 0 0 18%;
  min-width: 240px;
  max-width: 400px;
  background: #1f1f3b;
  transition: all 0.3s ease;
  overflow: hidden;
  border-right: 2px solid rgba(255, 255, 255, 0.06);
  position: relative;
}

/* Left container content wrapper */
.left-container-content {
  display: flex;
  flex-direction: column;
  padding: 10px;
  width: 100%;
  opacity: 1;
  transition: opacity 0.3s ease, visibility 0.3s ease;
  visibility: visible;
}

/* Collapsed left container */
.left-container.collapsed {
  flex: 0 0 10px !important;
  min-width: 10px !important;
  max-width: 10px !important;
  background: linear-gradient(90deg, #1f1f3b, #1a1a2e);
  box-shadow: 2px 0 8px rgba(0, 0, 0, 0.5);
}

/* Hide content when collapsed */
.left-container.collapsed .left-container-content {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

/* Show content on hover when collapsed */
.left-container.collapsed:hover {
  flex: 0 0 18% !important;
  min-width: 240px !important;
  max-width: 400px !important;
  background: #1f1f3b;
  z-index: 15;
}

.left-container.collapsed:hover .left-container-content {
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
}

/* Toggle button styles */
.left-container-toggle {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 30px;
  height: 30px;
  background-color: #32325A;
  border: none !important;
  border-radius: 50% !important;
  color: #cde2ff;
  cursor: pointer;
  z-index: 20;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  transition: all 0.2s ease;
  opacity: 0;
  padding: 0 !important;
  text-align: center !important;
  min-width: 30px !important;
  width: 30px !important;
}

/* Show toggle button on hover */
.left-container:hover .left-container-toggle {
  opacity: 1;
}

/* Position toggle button when collapsed */
.left-container.collapsed .left-container-toggle {
  right: -15px;
  opacity: 0;
}

/* Show toggle button when hovering on collapsed container */
.left-container.collapsed:hover .left-container-toggle {
  opacity: 1;
  right: 10px;
}

.left-container-toggle:hover {
  background-color: #454575 !important;
  transform: none !important;
  padding-left: 0 !important;
}

/* Jump button styles */
.jump-button {
  background-color: #304060 !important;
  margin-bottom: 15px !important;
  border: 1px solid #445580 !important;
  color: #00ffd1 !important;
  font-weight: 600 !important;
}

.jump-button:hover {
  background-color: #445580 !important;
}

/* Improved upload container */
.upload-json-container {
  margin-top: 20px;
  padding: 8px;
  background-color: rgba(42, 42, 80, 0.3);
  border-radius: 6px;
  border: 1px solid rgba(255, 255, 255, 0.05);
}
.upload-button-container {
  margin-top: 20px;
  padding: 8px;
  background-color: rgba(42, 42, 80, 0.3);
  border-radius: 6px;
  border: 1px solid rgba(255, 255, 255, 0.05);
}
/* Regular buttons in the left container */
.left-container button:not(.left-container-toggle) {
  background-color: #32325A;
  color: #cde2ff;
  border: 1px solid #444;
  width: 100%;
  padding: 12px;
  font-weight: 500;
  text-align: left;
  cursor: pointer;
  transition: background-color 0.2s, padding-left 0.2s;
  margin-bottom: 4px;
  border-radius: 4px;
}

.left-container button:not(.left-container-toggle):hover {
  background-color: rgba(0, 255, 209, 0.2);
  padding-left: 20px;
}

/* Folder tree container */
.folder-tree-container {
  margin: 10px 0;
  overflow-y: auto;
  max-height: calc(100vh - 300px);
}

/* MIDDLE CONTAINER */
.middle-container {
 flex: 2;
   display: flex;
   flex-direction: column;
   max-height: calc(100vh - 60px); /* This is good */
   height: calc(100vh - 60px); /* Adding explicit height */
   overflow-y: auto;
   overflow-x: hidden;
   background: linear-gradient(140deg, #1a1a2e 40%, #28284a 100%);
   transition: flex 0.3s ease, min-width 0.3s ease;
   border-right: 2px solid rgba(255, 255, 255, 0.06);
   position: relative;
   padding: 0 0 20px 0;
}

/* Middle container collapsed state */
.middle-container.collapsed {
  flex: 0 0 10px !important;
  min-width: 10px !important;
  overflow: hidden;
  background: linear-gradient(90deg, #1a1a2e, #242447);
}

/* Improved middle container toggle button positioning */
.middle-container-toggle {
  position: absolute;
  top: 50%;
  right: -14px; /* Position outside the container */
  transform: translateY(-50%);
  width: 28px;
  height: 28px;
  background-color: #242447;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  color: #cde2ff;
  cursor: pointer;
  z-index: 15;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
  padding: 0;
  font-size: 16px;
}

.middle-container-toggle:hover {
  background-color: #454575;
  color: #00ffd1;
}

/* Fix toggle icon when collapsed */
.middle-container.collapsed .middle-container-toggle {
  right: -14px; /* Keep it at the same position */
}

/* Let toggle button overlap with right container */
.right-container {
  flex: 3;
  display: flex;
  flex-direction: column;
  background-color: #18182f;
  position: relative;
  overflow: hidden;
  box-shadow: inset 0 0 10px #000;
  transition: flex 0.3s ease;
  margin-left: -14px; /* Negative margin to allow overlap */
  padding-left: 14px; /* Padding to prevent content being hidden */
  z-index: 10; /* Lower than toggle button */
}

/* Right container expands when middle is collapsed */
.middle-container.collapsed + .right-container {
  flex: 4;
}

/* Editor container for Monaco */
.editor-container {
  flex: 1;
  width: 100%;
  min-height: 0;
  position: relative;
  overflow: hidden;
}

/* JBMC / Modular actions section at top */
.jbmc-section {
  background-color: rgba(34, 255, 173, 0.07);
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  margin: 10px;
  padding: 10px;
  border-radius: 8px;
  /* Let it scroll if content is big */
  max-height: 200px;
  overflow-y: auto;
}

/* The modular actions section */
.modular-actions-section {
  background: rgba(42, 42, 66, 0.5);
  margin: 10px;

  border-radius: 8px;
  overflow-y: auto; /* Let it scroll if large */
  padding: 10px;
  border: 1px solid rgba(255, 255, 255, 0.08);
}

/* Modular Actions Container */
.modular-actions-container {
  display: flex;
  flex-direction: column;
  gap: 15px;
  padding: 5px;
}

/* JSON viewer section at bottom */
.json-viewer-section {
  background: rgba(42, 42, 66, 0.5);
  margin: 10px;
  /* Remove or adjust flex: 1 if it's forcing a height */
  /* flex: 1; */
  min-height: 0;
  border-radius: 8px;
  overflow-y: auto; /* Allows scrolling if content is large */
  padding: 10px;
  border: 1px solid rgba(255, 255, 255, 0.08);
}

/* JSON VIEWER STYLES */
.json-viewer {
  background-color: rgba(24, 24, 47, 0.8);
  color: #ffffff;
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 6px;
  padding: 10px;
  margin-bottom: 10px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
}
.json-display {
  max-height: 300px; /* you can adjust if needed */
  overflow: auto;
  margin-top: 6px;
  padding: 6px;
  background-color: #1a1a2f;
  border-radius: 4px;
}

/* Download button inside the JSON viewer */
.download-button {
  margin-top: 10px;
  padding: 8px 14px;
  background-color: #00ffd1;
  color: #000;
  border: 1px solid #2affdf;
  border-radius: 20px;
  cursor: pointer;
  transition: background-color 0.2s;
}
.download-button:hover {
  background-color: #2affdf;
}

/* TABLES: MergedAssignments etc. */
.merged-assignments-container {
  max-height: 240px; /* limit table's height so it can scroll */
  overflow-y: auto;
  margin-top: 0.5rem;
}
table {
  width: 100%;
  border-collapse: collapse;
  background-color: #24244f;
}
th, td {
  border: 1px solid #333;
  padding: 8px;
  text-align: left;
  font-size: 0.9rem;
}
th {
  background-color: #303060;
  color: #00ffd1;
  font-weight: 600;
}
tbody tr:nth-child(even) {
  background-color: rgba(255, 255, 255, 0.04);
}
tbody tr:hover {
  background-color: rgba(0, 255, 209, 0.15);
}

/* Buttons inside the middle container sections */
.jbmc-section button {
  background-color: #32325A;
  color: #cde2ff;
  border: 1px solid #444;
  padding: 8px 12px;
  margin: 6px 6px 6px 0;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s, transform 0.2s;
  min-width: 80px;
  display: inline-block;
}
.middle-container button {
  background-color: #32325A;
  color: #cde2ff;
  border: 1px solid #444;
  padding: 8px 12px;
  margin: 6px 6px 6px 0;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s, transform 0.2s;
  min-width: 30px;
  display: inline-block;
}
.middle-container button:hover,
.jbmc-section button:hover {
  background-color: #454575;
  transform: translateX(3px);
}

/* ---------- DECORATIONS FOR THE EDITOR (line highlights etc.) ---------- */
.inactive {
  background-color: rgba(255, 60, 60, 0.45) !important; /* translucent red */
}
.active {
  background-color: rgba(60, 255, 60, 0.35) !important; /* translucent green */
}
.link {
  background-color: rgba(30, 144, 255, 0.6) !important; /* dodgerblue */
}
.loop {
  background-color: rgba(128, 0, 128, 0.5) !important;  /* purple */
}
.start {
  content: url('../Images/start.png');
}
.line {
  content: url('../Images/line.png');
}
.end {
  content: url('../Images/end.png');
}
.one-line {
  content: url('../Images/oneLine.png');
}

/* Additional popup styling (if used) */
.popup {
  position: absolute;
  background-color: #FFF;
  color: #000;
  border: 1px solid #CCC;
  padding: 10px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.5);
  z-index: 1000;
}

/* MONACO TOKEN COLORS OVERRIDES */
.monaco-editor.token.keyword {
  color: #FFC1F3 !important; /* Pastel pink for keywords */
  font-weight: bold;
}
.monaco-editor.token.function {
  color: #AFFFD1 !important; /* Light teal for function names */
}
.monaco-editor.token.type {
  color: #FFCB6B !important;
}
.monaco-editor.token.identifier {
  color: #D6DEEB !important;
}
.monaco-editor.token.string {
  color: #C3E88D !important;
}
.monaco-editor.token.number {
  color: #F78C6C !important;
}
.monaco-editor.token.operator {
  color: #89DDFF !important;
}
.monaco-editor.token.annotation {
  color: #82AAFF !important;
}
.monaco-editor.token.regex {
  color: #ECC48D !important;
}
.monaco-editor.token.delimiter {
  color: #89DDFF !important;
}
.monaco-editor.token.invalid {
  background-color: #FF5370 !important;
  color: #FFF !important;
}

/* MONACO EDITOR HOVER */
.monaco-editor .monaco-editor-hover {
  z-index: 1000;
  position: fixed;
  visibility: visible;
}
.monaco-editor-hover .monaco-editor-hover-content {
  background-color: #FFF;
  color: #000;
  border: 1px solid #444;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  padding: 8px;
}

/* Modal styling (Help, etc.) */
.modal-container {
  max-width: 600px;
  margin: 100px auto;
  padding: 20px;
  background-color: #26264a;
  color: #E8F5FF;
  border-radius: 10px;
  border: 2px solid #444;
  box-shadow: 0 10px 20px rgba(0,0,0,0.6);
}
.modal-close-button {
  background-color: #00ffd1;
  color: #000;
  border: 1px solid #2affdf;
  padding: 8px 16px;
  font-size: 16px;
  cursor: pointer;
  border-radius: 4px;
}
.modal-content {
  margin-top: 20px;
}
.modal {
  /* If you need to style the overall modal container from ReactModal, do it here */
}

/* Buttons used in the top left area (like "Upload") */
.upload-button-container,
.reset-button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 1rem 0;
}
.picker {
  margin-right: 0;
  margin-bottom: 1rem;
  color: #cde2ff;
  background-color: #32325A;
  border: 1px solid #444;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}
.picker:hover {
  background-color: #454575;
}

/* TRACE TREE STYLES */
.trace-tree-container {
  margin: 10px;
  padding: 10px;
  background-color: rgba(42, 42, 80, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  color: #cde2ff;
  max-height: 200px;
  overflow-y: auto;
}
.trace-tree-container ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
}
.trace-tree-container li {
  margin: 4px 0;
  cursor: pointer;
  transition: background-color 0.2s, padding-left 0.2s;
}
.trace-tree-container li:hover {
  background-color: rgba(0, 255, 209, 0.15);
  padding-left: 8px;
}

/* METHOD VIEW SECTION */
.method-view-section {
  margin: 10px;
  padding: 10px;
  background: rgba(42, 42, 80, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  color: #cde2ff;
  max-height: 200px;
  overflow-y: auto;
}
.method-view-section h3 {
  margin: 0 0 8px 0;
  font-size: 1rem;
}
.method-view-section select.method-view-dropdown {
  width: 100%;
  padding: 8px;
  background-color: #333;
  color: #fff;
  border: 1px solid #444;
  border-radius: 4px;
  font-size: 0.9rem;
}

/* HIGHLIGHTED METHODS OR TRACE NODES */
.trace-tree-clickable.highlight,
.highlighted-method {
  background-color: rgba(0, 255, 209, 0.25);
  border-radius: 3px;
}

/* ---------- SCROLLBAR STYLING (optional) --------- */
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: #1a1a2e;
}
::-webkit-scrollbar-thumb {
  background: #2affdf66;
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #2affdf;
}

/* Form elements styling */
.form-group {
  margin: 10px 0;
}

.input-field {
  background-color: #242447;
  color: #cde2ff;
  border: 1px solid #444;
  padding: 8px;
  border-radius: 4px;
  width: 100%;
  max-width: 300px;
  transition: border-color 0.2s;
}

.input-field:focus {
  border-color: #00ffd1;
  outline: none;
}

.action-group {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Active tab styling */
.active-tab {
  background-color: #00ffd1 !important;
  color: #1a1a2e !important;
}

/* Button group */
.button-group {
  display: flex;
  gap: 8px;
  margin: 10px 0;
}

/* Collapsible sections styling */
.collapsible-section {
 margin: 10px;
  border-radius: 8px;
  overflow: visible; /* Changed from hidden to allow content to scroll in container */
  transition: all 0.3s ease;
  background: rgba(42, 42, 66, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.08);
  display: flex;
  flex-direction: column;
  max-height: unset;
}

.collapsible-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 15px;
  background: linear-gradient(140deg, #24244b 0%, #32325A 100%);
  cursor: pointer;
  transition: background 0.2s;
}

.collapsible-header:hover {
  background: linear-gradient(140deg, #32325A 0%, #454575 100%);
}

.collapsible-header h3 {
  margin: 0;
  font-size: 1rem;
  font-weight: 600;
  color: #00ffd1;
}

.collapse-icon {
  color: #cde2ff;
  font-size: 0.8rem;
}
/* NewWelcomeScreen.css */

.welcome-screen {
  position: relative;
  width: 100vw;
  height: 100vh;
  background: #0f0f1f;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  color: #e8f5ff;
}

/* Subtle gradient overlay animation */
.welcome-screen__overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(45% 45% at 30% 30%, rgba(0,255,209, 0.2), transparent 70%),
              radial-gradient(60% 60% at 70% 60%, rgba(30, 144, 255, 0.2), transparent 80%),
              radial-gradient(40% 40% at 80% 10%, rgba(180, 0, 255, 0.3), transparent 70%);
  animation: moveGradient 12s ease-in-out infinite alternate;
  z-index: 1;
}

/* Animate the radial gradients */
@keyframes moveGradient {
  0% {
    transform: translate3d(0, 0, 0);
  }
  100% {
    transform: translate3d(-5%, -5%, 0);
  }
}

/* The content container */
.welcome-screen__content {
  position: relative;
  z-index: 2;
  max-width: 500px;
  text-align: center;
  padding: 2rem;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 10px;
  background-color: rgba(26, 26, 46, 0.75);
}

/* Title style */
.welcome-screen__title {
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: #00ffd1;
  text-shadow: 0 0 8px rgba(0, 255, 209, 0.5);
}

/* Subtitle */
.welcome-screen__subtitle {
  font-size: 1.1rem;
  margin-bottom: 2rem;
  color: #b0fdf6;
  line-height: 1.4;
}

/* Form and inputs */
.welcome-screen__form {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.welcome-screen__label {
  margin-bottom: 0.5rem;
  color: #aaa;
}

.welcome-screen__input {
  padding: 0.6rem 1rem;
  border: 1px solid #444;
  border-radius: 4px;
  background-color: #1a1a2f;
  color: #cde2ff;
  min-width: 260px;
  text-align: center;
}
.welcome-screen__input:focus {
  outline: none;
  border-color: #00ffd1;
}

/* Buttons */
.welcome-screen__buttons {
  display: flex;
  gap: 0.8rem;
}

/* Reusable "neon" button classes */
.btn {
  cursor: pointer;
  padding: 0.6rem 1.2rem;
  font-size: 1rem;
  border: none;
  border-radius: 4px;
  transition: box-shadow 0.3s, transform 0.3s;
}

.btn:hover {
  transform: translateY(-2px);
}

/* Neon style variations */
.btn.neon {
  background-color: #00ffd1;
  color: #0f0f1f;
  box-shadow: 0 0 8px rgba(0, 255, 209, 0.5);
}
.btn.neon:hover {
  box-shadow: 0 0 12px rgba(0, 255, 209, 0.8);
}

.btn.neon-green {
  background-color: #57ff89;
  color: #0f0f1f;
  box-shadow: 0 0 8px rgba(87, 255, 137, 0.5);
}
.btn.neon-green:hover {
  box-shadow: 0 0 12px rgba(87, 255, 137, 0.8);
}

.collapsible-content {
 padding: 10px;
   overflow-y: visible;
}

.collapsible-section.collapsed {
  max-height: 38px; /* Header height */
  transition: max-height 0.3s ease;
}

.collapsible-section.expanded {
  max-height: 1000px; /* Arbitrary large value */
  transition: max-height 0.3s ease;
}

/* Tab navigation styling */
.tab-navigation {
  display: flex;
  gap: 2px;
  background-color: #1a1a2e;
  padding: 5px 5px 0;
  border-radius: 6px 6px 0 0;
  margin-bottom: 10px;
}

.tab-button {
  padding: 8px 16px;
  background-color: #32325A;
  color: #cde2ff;
  border: none;
  border-radius: 6px 6px 0 0;
  cursor: pointer;
  transition: all 0.2s;
}

.tab-button.active {
  background-color: #00ffd1;
  color: #1a1a2e;
}

.tab-content {
  background-color: rgba(42, 42, 66, 0.3);
  border-radius: 0 0 6px 6px;
  padding: 10px;
}

/* Additional scrolling improvements for sections */
.jbmc-section,
.modular-actions-section,
.json-viewer-section,
.trace-tree-container,
.method-view-section,
.collapsible-content {
  overflow-y: auto;
  max-height: calc(100vh - 200px);
  scrollbar-width: thin; /* For Firefox */
}

/* Additional helper class for toggle button content */
.toggle-icon {
  font-size: 12px;
  font-weight: bold;
}
===== ./index.js =====
// Imports the React module.
import React from 'react';

// Imports the ReactDom module from 'react-dom/client'(refers to newest react version).
import {createRoot} from 'react-dom/client';

// Imports CSS-File for styling.
import './Css/App.css';

// Imports the App-component from App.js.
import App from './App.js';

// Imports the function reportWebVitals for measuring the performance of the web application.
import reportWebVitals from './ReportWebVitals.js';

// Determines the DOM-Element with the ID 'root' that is used as an anchor point for the React application.
const rootElement = document.getElementById('root');

// Checks if the 'rootElement' is present to prevent errors.
if (rootElement) {
    // Creates the Root-Element through 'createRoot' from 'react-dom/client'.
    const root = createRoot(rootElement);

    // Uses 'root.render()', to render the app-component inside the <React.StrictMode>-wrapper.
    // <React.StrictMode> is used to activate additional tests and warnings for the app.
    root.render(
        <React.StrictMode>
            <App/>
        </React.StrictMode>
    );
}

// Create a button to open a new project session
document.addEventListener('DOMContentLoaded', function() {
    // Create new project button
    var newProjectBtn = document.createElement('button');
    newProjectBtn.textContent = 'New Project';
    newProjectBtn.style.position = 'fixed';
    newProjectBtn.style.bottom = '20px';
    newProjectBtn.style.right = '20px';
    newProjectBtn.style.padding = '10px 20px';
    newProjectBtn.style.backgroundColor = '#4CAF50';
    newProjectBtn.style.color = 'white';
    newProjectBtn.style.border = 'none';
    newProjectBtn.style.borderRadius = '5px';
    newProjectBtn.style.cursor = 'pointer';
    newProjectBtn.style.zIndex = '1000';

    newProjectBtn.addEventListener('click', function() {
        window.open('/new-project', '_blank');
    });


});

// reportWebVitals is called to capture performance data and report it.
// This can be used for analysing and optimizing the performance.
// More information about this process can be found here: https://bit.ly/CRA-vitals
reportWebVitals(console.log);  //'console.log' gets passed on as an example-callback-function.===== ./WebsiteElements/MethodTreeView.js =====
// MethodTreeView.js

import React, { useState, useMemo } from "react";
import PropTypes from "prop-types";

/**
 * Build a tree of "Function" nodes from jsonManager.nodes:
 * - Each node gains a `children` array, containing child function nodes.
 * - Return an array of "root" function nodes (those whose parent is not a function).
 */
function buildFunctionTree(jsonManager) {
  if (!jsonManager || !jsonManager.nodes) {
    return [];
  }

  // 1) Create a quick map from node index -> node
  const indexToNode = {};
  jsonManager.nodes.forEach((node, idx) => {
    indexToNode[idx] = node;
  });

  // 2) Prepare each node for children
  jsonManager.nodes.forEach((node) => {
    // We'll add a `children` array
    node.children = [];
  });

  // 3) For each function node, push any child function nodes
  jsonManager.nodes.forEach((node, idx) => {
    if (node.nodeType === "Function") {
      node.childrenIndices.forEach((childIndex) => {
        const childNode = indexToNode[childIndex];
        if (childNode && childNode.nodeType === "Function") {
          // childNode is also a function, so nest it
          node.children.push(childNode);
        }
      });
    }
  });

  // 4) Identify root function nodes:
  //    (1) parentIndex is null/negative, or
  //    (2) parent's nodeType != "Function"
  const rootFunctions = [];
  jsonManager.nodes.forEach((node, idx) => {
    if (node.nodeType === "Function") {
      const parentIndex = node.parentIndex;
      if (
        parentIndex === null ||
        parentIndex < 0 ||
        indexToNode[parentIndex].nodeType !== "Function"
      ) {
        rootFunctions.push(node);
      }
    }
  });

  return rootFunctions;
}

/**
 * Recursive component that displays a single function node.
 * - Expands/collapses if it has child function nodes.
 * - Renders a "Select" button to pick this node.
 */
function FunctionTreeItem({ node, onSelect }) {
  // Local expanded/collapsed state
  const [expanded, setExpanded] = useState(false);

  // If node has child function nodes
  const hasChildren = node.children && node.children.length > 0;

  const toggleExpand = (e) => {
    e.stopPropagation(); // so we don't conflict with the button's click
    setExpanded((prev) => !prev);
  };

  const handleSelect = (e) => {
    e.stopPropagation();
    onSelect(node);
  };

  return (
    <li style={{ margin: "4px 0" }}>
      <div
        style={{
          display: "flex",
          alignItems: "center",
          cursor: hasChildren ? "pointer" : "default",
        }}
        onClick={toggleExpand}
      >
        {hasChildren && (
          <span style={{ marginRight: "6px", fontSize: "0.8rem" }}>
            {expanded ? "▼" : "►"}
          </span>
        )}
        {!hasChildren && <span style={{ marginRight: "14px" }} />}
        {/* just spacing if no children */}

        <button
          style={{ marginRight: "8px" }}
          onClick={handleSelect}
        >
          Select
        </button>
        <span>{node.nodeMethodName || "UnnamedMethod"}</span>
      </div>
      {hasChildren && expanded && (
        <ul style={{ listStyle: "none", marginLeft: "20px", paddingLeft: 0 }}>
          {node.children.map((child, idx) => (
            <FunctionTreeItem key={idx} node={child} onSelect={onSelect} />
          ))}
        </ul>
      )}
    </li>
  );
}

FunctionTreeItem.propTypes = {
  node: PropTypes.object.isRequired,   // a single function node
  onSelect: PropTypes.func.isRequired, // callback when user clicks "Select"
};

/**
 * Main component that:
 *  - Builds the function tree from jsonManager
 *  - Renders root-level function nodes, each of which
 *    recursively renders children
 *  - Calls onSelectMethod when user selects a node
 */
export default function MethodTreeView({ jsonManager, onSelectMethod, className }) {
  // Build the tree once
  const rootFunctions = useMemo(() => buildFunctionTree(jsonManager), [jsonManager]);

  if (!jsonManager || !jsonManager.nodes) {
    return <div className={className}>No jsonManager or nodes available.</div>;
  }

  if (rootFunctions.length === 0) {
    return <div className={className}>No function nodes found.</div>;
  }

  // On "Select" we find the node's index in jsonManager.nodes, pass to onSelectMethod
  const handleSelectNode = (node) => {
    const idx = jsonManager.nodes.indexOf(node);
    onSelectMethod(idx);
  };

  return (
    <div className={className}>
      <h3>Method Hierarchy (Tree)</h3>
      <ul style={{ listStyle: "none", paddingLeft: 0 }}>
        {rootFunctions.map((rootNode, i) => (
          <FunctionTreeItem
            key={i}
            node={rootNode}
            onSelect={handleSelectNode}
          />
        ))}
      </ul>
    </div>
  );
}

MethodTreeView.propTypes = {
  jsonManager: PropTypes.object,
  onSelectMethod: PropTypes.func.isRequired,
  className: PropTypes.string,
};===== ./WebsiteElements/ReadmeModal.js =====
import React, {useState} from 'react';
import PropTypes from "prop-types";

/**
 * Defines a modal component that displays readme or help information to the user.
 * This functional component renders a modal dialog containing a title and a message
 * indicating that help will not be provided from external sources. A close button is
 * also provided, allowing the user to dismiss the modal. This component demonstrates
 * the use of props in React for passing the closeModal function, enabling the modal
 * to be closed from within.
 * @param {Function} props.closeModal - Function to close the modal.
 */
export default function ReadmeModal({closeModal}) {
    const content = [
        <div key={1}><b> Welcome to ProRunVis: </b>
            <p> ProRunVis is a code analysis tool that is supposed to help you understand the control flow of your
                code through visualization. </p></div>,
        <div key={2}><b> Upload: </b>
            <p> Use the <b>choose-files-button</b> to upload the root folder of a Java project of your choosing. </p>
            <p> The chosen project has to be in a separate folder with only the project-packages in it. It
                furthermore should not use any external libraries the program is currently not able to deal with
                those.</p>
            <p> The code of your project then gets shown on the <b>right side</b>. </p></div>,
        <div key={3}><b> Visualization: </b>
            <p> Only one function call is visualized at the same time. </p>
            <p style={{backgroundColor: "green"}}> <b>Green</b> background indicates that a statement has been
                executed. </p>
            <p style={{backgroundColor: "blue"}}> <b>Blue</b> background indicates a jump at that position to another part
                of the
                code. Click it to go there and change the function call currently visualized. </p>
            <p style={{backgroundColor: "purple"}}> <b>Purple</b> background indicates a loop that has been executed, click
                it to
                select the iteration that you
                want displayed. </p>
            
            <p> The <b>line</b> on the left side of your code is shown to indicate what path the program took.
                It is decorated with <b>elements</b> that help you to identify specific code structures such as loops or
                    function calls.</p></div>,
        <div key={4}><b> Navigation: </b>
            <p> You can use the <b>directory bar</b> on the left side to open all the Java files in your project. </p>
            <p> If you want to jump back to the file with the function currently visualized you can use the <b>Jump-to-active-function-button</b>, it will open the file for you and display the function.</p> </div>];

    const [currentIndex, setCurrentIndex] = useState(0);

    const handleBack = () => {
        setCurrentIndex((prevIndex) => Math.max(prevIndex - 1, 0));
    };

    const handleNext = () => {
        setCurrentIndex((prevIndex) => Math.min(prevIndex + 1, content.length - 1));
    };

    return (
        <div className="modal-container">
            <button className="modal-close-button" onClick={closeModal}>
                Close
            </button>
            <div className="modal-content">
                <h2><u>Tutorial</u></h2>
            </div>
            <div className="modal-buttons">
                <button onClick={handleBack} disabled={currentIndex === 0}>
                    Back
                </button>
                <button onClick={handleNext} disabled={currentIndex === content.length - 1}>
                    Next
                </button>
                <b> {currentIndex + 1} / {content.length} </b>
            </div>
            <div><p></p>{content[currentIndex]}</div>
        </div>
    );
}
    ReadmeModal.propTypes = {
        closeModal: PropTypes.instanceOf(Function)
    };===== ./WebsiteElements/Navbar.js =====
// src/WelcomeScreen.js
import React, { useState } from "react";

export default function WelcomeScreen() {
  // For typed project ID
  const [typedProjectId, setTypedProjectId] = useState("");

  // Called when user clicks "Open Project"
  const handleOpenProject = () => {
    if (!typedProjectId) {
      alert("Please enter a project ID or choose 'New Project' instead.");
      return;
    }
    // Navigate to /?projectId=theTypedValue, same tab
    window.location.href = `/?projectId=${encodeURIComponent(typedProjectId)}`;
  };

  // Called when user clicks "New Project"
  const handleNewProject = async () => {
    // Option A: Just go to /new-project in the same tab
    // window.location.href = "/new-project";

    // Option B: Call an API to create a brand new ID, then redirect
    try {
      const resp = await fetch("/api/new-project", { method: "POST" });
      if (!resp.ok) {
        const errText = await resp.text();
        throw new Error(errText);
      }
      const data = await resp.json();
      const newId = data.projectId; // e.g. "some-uuid"
      window.location.href = `/?projectId=${encodeURIComponent(newId)}`;
    } catch (error) {
      alert("Failed to create a new project: " + error.message);
    }
  };

  return (
    <div
      style={{
        width: "100vw",
        height: "100vh",
        background: "#1a1a2e",
        color: "#fff",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
      }}
    >
      <h1 style={{ marginBottom: "1rem" }}>Welcome to ProRunVis!</h1>
      <p style={{ marginBottom: "2rem" }}>
        Your code visualization tool. Please open an existing project or create a new one.
      </p>

      <div style={{ marginBottom: "1.5rem" }}>
        <input
          type="text"
          placeholder="Enter existing Project ID"
          value={typedProjectId}
          onChange={(e) => setTypedProjectId(e.target.value)}
          style={{
            padding: "8px",
            fontSize: "16px",
            borderRadius: "4px",
            border: "1px solid #444",
            marginRight: "8px",
          }}
        />
        <button
          onClick={handleOpenProject}
          style={{
            padding: "8px 16px",
            fontSize: "16px",
            backgroundColor: "#00ffd1",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          Open Project
        </button>
      </div>

      <button
        onClick={handleNewProject}
        style={{
          padding: "8px 24px",
          fontSize: "16px",
          backgroundColor: "#4CAF50",
          border: "none",
          borderRadius: "4px",
          cursor: "pointer",
        }}
      >
        New Project
      </button>
    </div>
  );
}===== ./WebsiteElements/JsonViewer.js =====
import React from 'react';
import ReactJson from 'react-json-view';
import '../Css/App.css';
import PropTypes from 'prop-types';

function JsonViewer({ jsonData, onElementClick }) {
    const handleJsonClick = (click) => {
        if (onElementClick) {
            if (click.updated_src) {
                onElementClick(click.updated_src);
            } else if (click.namespace) {
                onElementClick(click.namespace);
            }
        }
    };

    const handleDownload = () => {
        const fileName = 'data.json';
        const jsonStr = JSON.stringify(jsonData, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(url);
    };

    return (
        <div className="json-viewer">
            <h2>JSON-Datei anzeigen</h2>
            <div className="json-display">
                <ReactJson
                    src={jsonData}
                    theme="monokai"
                    collapsed={2}
                    enableClipboard={true}
                    onEdit={handleJsonClick}
                    onDelete={handleJsonClick}
                    onAdd={handleJsonClick}
                    onSelect={handleJsonClick}
                />
            </div>
            <button onClick={handleDownload} className="download-button">
                JSON-Datei herunterladen
            </button>
        </div>
    );
}

JsonViewer.propTypes = {
    jsonData: PropTypes.object.isRequired,
    onElementClick: PropTypes.func
};

export default JsonViewer;===== ./WebsiteElements/CollapsibleSection.js =====
import React, { useState } from 'react';
import PropTypes from 'prop-types';

const CollapsibleSection = ({ title, defaultOpen = true, className = '', children }) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className={`collapsible-section ${className} ${isOpen ? 'expanded' : 'collapsed'}`}>
      <div className="collapsible-header" onClick={() => setIsOpen(!isOpen)}>
        <h3>{title}</h3>
        <span className="collapse-icon">{isOpen ? '▼' : '►'}</span>
      </div>
      {isOpen && <div className="collapsible-content">{children}</div>}
    </div>
  );
};

CollapsibleSection.propTypes = {
  title: PropTypes.string.isRequired,
  defaultOpen: PropTypes.bool,
  className: PropTypes.string,
  children: PropTypes.node
};

export default CollapsibleSection;===== ./WebsiteElements/StaticMethodsView.js =====
// StaticMethodsView.js
import React, { useEffect, useState } from 'react';

const StaticMethodsView = () => {
  const [methods, setMethods] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  // Fetch the static methods from the endpoint when the component mounts
  useEffect(() => {
    setLoading(true);
    fetch('/api/static-methods')
      .then((response) => {
        if (!response.ok) {
          throw new Error('Network response was not ok.');
        }
        return response.json();
      })
      .then((data) => {
        setMethods(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err.message);
        setLoading(false);
      });
  }, []);

  return (
    <div style={{ padding: '1rem', backgroundColor: '#222', color: '#fff' }}>
      <h2>Static Methods (Extracted from Source Code)</h2>
      {loading && <div>Loading static methods...</div>}
      {error && <div style={{ color: 'red' }}>Error: {error}</div>}
      {methods && (
        <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
          {JSON.stringify(methods, null, 2)}
        </pre>
      )}
    </div>
  );
};

export default StaticMethodsView;===== ./WebsiteElements/TraceTree.js =====
import React from 'react';
import PropTypes from 'prop-types';

/**
 * Renders a tree/list of all TraceNodes from your jsonManager.
 *
 * - nodes: an array of all nodes (jsonManager.nodes).
 * - onSelectTraceNode: callback, called when user clicks a node in the tree,
 *                      typically so you can highlight in the code editor.
 * - hoveredTraceId: if you want to highlight an item when user hovers code,
 *                   pass the traceId here (optional).
 */
export default function TraceTree({ nodes, onSelectTraceNode, hoveredTraceId }) {
  if (!nodes || nodes.length === 0) {
    return <div>No trace data.</div>;
  }

  return (
    <div style={{ overflowY: 'auto', maxHeight: '200px', border: '1px solid #666' }}>
      <h3>Trace Tree</h3>
      <ul style={{ paddingLeft: '1rem' }}>
        {nodes.map((node, idx) => (
          <li
            key={node.traceId || idx}
            style={{
              backgroundColor:
                hoveredTraceId && hoveredTraceId === node.traceId
                  ? 'yellow'
                  : 'transparent',
            }}
            onClick={() => onSelectTraceNode(node)}
          >
            {/* Show ID and maybe method name */}
            <b>{node.traceId}</b> {/* Use node.traceId directly */}
            ({node.nodeType}
            {node.nodeMethodName ? `: ${node.nodeMethodName}` : ''})
          </li>
        ))}
      </ul>
    </div>
  );
}

TraceTree.propTypes = {
  nodes: PropTypes.array.isRequired,
  onSelectTraceNode: PropTypes.func.isRequired,
  hoveredTraceId: PropTypes.string,
};===== ./WebsiteElements/DirectoryBar.js =====
import React, { useEffect, useState } from 'react';
import FolderTree from 'react-folder-tree';
import 'react-folder-tree/dist/style.css';
import "../Css/App.css";
import PropTypes from "prop-types";

/**
 * Left-side component for uploading a Java folder and optionally a JSON file.
 * There's no direct display of project ID here; we rely on the parent's single
 * "Project ID" field.
 */
function DirectoryBar({
  setDisplayedFile,
  setDisplayedToActive,
  passOnUploadedFiles,
  passOnJsonData,
  projectId
}) {
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [folderTreeData, setFolderTreeData] = useState(null);
  const [isLeftContainerCollapsed, setIsLeftContainerCollapsed] = useState(false);

  // Called when user picks a local folder containing .java files
  const handleFileUpload = (event) => {
    const filteredFiles = Array.from(event.target.files).filter(file =>
      file.webkitRelativePath.endsWith('.java')
    );
    setUploadedFiles(filteredFiles);

    if (filteredFiles.length > 0) {
      const folderName = filteredFiles[0].webkitRelativePath.split('/')[0];
      const treeData = buildFolderTree(filteredFiles, folderName);
      setFolderTreeData(treeData);
    }
  };

  // Build a "folder tree" data structure for FolderTree
  const buildFolderTree = (fileList, rootFolderName) => {
    const root = { name: rootFolderName, isOpen: true, children: [] };
    let i = 0;

    fileList.forEach((file) => {
      const pathParts = file.webkitRelativePath.split('/');
      let currentLevel = root;

      pathParts.forEach((part, idx) => {
        if (idx > 0) {
          const nodeName = part.replace('.java', '');
          let existing = currentLevel.children.find(child => child.name === nodeName);
          const isDirectory = idx < pathParts.length - 1;

          if (!isDirectory && !existing) {
            existing = {
              name: nodeName,
              realPath: file.webkitRelativePath,
              index: i,
              children: undefined,
            };
            currentLevel.children.push(existing);
            i++;
          } else if (!existing) {
            existing = { name: nodeName, children: [] };
            currentLevel.children.push(existing);
          }
          currentLevel = existing;
        }
      });
    });

    return root;
  };

  // Toggle the collapsed/expanded state of the left container
  const toggleLeftContainer = () => {
    setIsLeftContainerCollapsed(!isLeftContainerCollapsed);
  };

  // When user clicks on a node (file) in FolderTree
  const onNameClick = ({ nodeData }) => {
    const { realPath, index } = nodeData;
    if (realPath != null) {
      setDisplayedFile(uploadedFiles[index]);
    }
  };

  // Handle JSON file upload
  const handleJsonFileUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      uploadJsonFileToBackend(file);
    }
  };

  // POST the JSON file to the server
  const uploadJsonFileToBackend = async (file) => {
    if (!projectId) {
      alert("Please enter a Project ID before uploading JSON files");
      return;
    }

    const formData = new FormData();
    formData.append('jsonFile', file);
    formData.append('projectId', projectId);

    try {
      const res = await fetch('/api/upload-json', {
        method: 'POST',
        body: formData,
      });
      if (!res.ok) {
        alert("Error uploading JSON file.");
        return;
      }
      const jsonData = await res.json();
      passOnJsonData(jsonData);
      alert("JSON file successfully uploaded!");
    } catch (error) {
      console.error("Error uploading JSON file:", error);
      alert("An unexpected error occurred.");
    }
  };

  // If `uploadedFiles` changes, pass them upward
  useEffect(() => {
    if (uploadedFiles.length > 0) {
      passOnUploadedFiles(uploadedFiles);
    }
  }, [uploadedFiles, passOnUploadedFiles]);

  return (
    <main className={`left-container ${isLeftContainerCollapsed ? 'collapsed' : ''}`}>
      <button
        className="left-container-toggle"
        onClick={toggleLeftContainer}
        title={isLeftContainerCollapsed ? "Expand directory" : "Collapse directory"}
      >
        {isLeftContainerCollapsed ? '►' : '◄'}
      </button>

      <div className="left-container-content">
        <button onClick={setDisplayedToActive} className="jump-button">
          Jump to active function
        </button>

        {/* Only a hidden input for projectId is used by the forms */}
        <div className="upload-button-container">
          <form id="upload-form" className="text-box" encType="multipart/form-data">
            <input type="hidden" name="projectId" value={projectId || ''} />
            <input
              type="file"
              name="file"
              multiple
              webkitdirectory=""
              onChange={handleFileUpload}
              className="picker"
            />
          </form>
        </div>

        <div className="upload-json-container">
          <form id="json-upload-form" encType="multipart/form-data">
            <input type="hidden" name="projectId" value={projectId || ''} />
            <input
              type="file"
              name="jsonFile"
              accept=".json"
              onChange={handleJsonFileUpload}
              className="picker"
            />
          </form>
        </div>

        {folderTreeData && (
          <div className="folder-tree-container">
            <FolderTree
              data={folderTreeData}
              onNameClick={onNameClick}
              showCheckbox={false}
              readOnly={true}
              indentPixels={15}
            />
          </div>
        )}
      </div>
    </main>
  );
}

DirectoryBar.propTypes = {
  setDisplayedFile: PropTypes.func.isRequired,
  setDisplayedToActive: PropTypes.func.isRequired,
  passOnUploadedFiles: PropTypes.func.isRequired,
  passOnJsonData: PropTypes.func.isRequired,
  projectId: PropTypes.string,
};

export default DirectoryBar;===== ./WebsiteElements/MergedAssignmentsTable.js =====
import React, { useEffect, useState } from "react";
import PropTypes from "prop-types";

function MergedAssignmentsTable({ traceId, projectId, selectedVariable }) {
  const [allRows, setAllRows] = useState([]);

  useEffect(() => {
    // Only fetch data if both traceId and projectId are available
    if (!traceId || !projectId) return;

    // Fetch processed trace (the array of nodes) using projectId
    fetch(`/api/jbmc/flatten?projectId=${projectId}`)
      .then((res) => {
        if (!res.ok) {
          throw new Error(`Failed to load processed trace for projectId=${projectId}`);
        }
        return res.json();
      })
      .then((nodeList) => {
        // Flatten each node’s jbmcValues to produce an array of rows
        const flattened = flattenAssignments(nodeList);
        setAllRows(flattened);
      })
      .catch((err) => {
        console.error("Error fetching or flattening merged JBMC data:", err);
      });
  }, [traceId, projectId, selectedVariable]);

  // Filter the rows if a selectedVariable is provided
  const rowsToDisplay = selectedVariable
    ? allRows.filter(row => row.variableName === selectedVariable)
    : allRows;

  return (
    <div style={{ margin: "1rem", padding: "1rem", backgroundColor: "#2A2A2A" }}>
      <h3>Merged JBMC/Trace Assignments</h3>
      {rowsToDisplay.length === 0 ? (
        <p>No variable assignments to display (maybe no merges or no JBMC data, or no matching variable).</p>
      ) : (
        <table style={{ borderCollapse: "collapse", width: "100%" }}>
          <thead>
            <tr>
              <th style={thStyle}>Node Trace ID</th>
              <th style={thStyle}>Variable</th>
              <th style={thStyle}>Iteration</th>
              <th style={thStyle}>Value</th>
            </tr>
          </thead>
          <tbody>
            {rowsToDisplay.map((row, idx) => (
              <tr key={idx}>
                <td style={tdStyle}>{row.nodeTraceId}</td>
                <td style={tdStyle}>{row.variableName}</td>
                <td style={tdStyle}>{row.iteration}</td>
                <td style={tdStyle}>{row.value}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

MergedAssignmentsTable.propTypes = {
  traceId: PropTypes.string.isRequired,
  projectId: PropTypes.string.isRequired,
  selectedVariable: PropTypes.string // optional
};

// Helper function to flatten each node's jbmcValues
function flattenAssignments(nodeList) {
  const result = [];
  nodeList.forEach((node) => {
    if (!node.jbmcValues) return;
    Object.entries(node.jbmcValues).forEach(([varName, varValues]) => {
      varValues.forEach((valObj) => {
        result.push({
          nodeTraceId: valObj.traceId,
          variableName: varName,
          iteration: valObj.iteration,
          value: valObj.value
        });
      });
    });
  });
  return result;
}

// Inline styles for table headers and cells
const thStyle = {
  border: "1px solid gray",
  backgroundColor: "#444",
  padding: "6px"
};
const tdStyle = {
  border: "1px solid gray",
  padding: "6px"
};

export default MergedAssignmentsTable;===== ./WebsiteElements/HelpButton.js =====
import React, {useState} from "react";
import Modal from "react-modal";
import ReadmeModal from "./ReadmeModal";
import "../Css/App.css"

// Sets the app element for accessibility reasons, which helps screen readers.
Modal.setAppElement("#root");

/**
 * Defines a HelpButton component using ReactModal for displaying help information.
 * This component manages the state of the modal (open/close) and renders a button
 * that, when clicked, opens a modal containing the ReadmeModal component. This modal
 * provides help or documentation to the user. The component demonstrates the use of
 * React's useState hook for state management and the integration of third-party modal
 * functionality for enhanced UI interactions.
 */
export default function HelpButton() {
    // State to track if the modal is open or closed.
    const [modalIsOpen, setModalIsOpen] = useState(false);

    /**
     * Opens the modal by setting the modalIsOpen state to true.
     */
    const openModal = () => {
        setModalIsOpen(true);
    };

    /**
     * Closes the modal by setting the modalIsOpen state to false.
     */
    const closeModal = () => {
        setModalIsOpen(false);
    };

    return (
        <>
            <button className="nav--help-button" onClick={openModal}>
                Help
            </button>
            <Modal className="modal"
                isOpen={modalIsOpen}
                onRequestClose={closeModal}
                contentLabel="Readme Modal"
            >
                <ReadmeModal closeModal={closeModal/* Renders the content of the modal.*/}/>
            </Modal>
        </>
    );
}
===== ./ModularActions.js =====
import React, { useState } from 'react';
import PropTypes from 'prop-types';
import CollapsibleSection from './WebsiteElements/CollapsibleSection';

function ModularActions({ setJsonManager, projectName, onVisualize }) {
  // Local state variables, including the sole source for project ID
  const [localProjectId, setLocalProjectId] = useState("");
  const [instrumentId, setInstrumentId] = useState("");
  const [traceId, setTraceId] = useState("");
  const [processedTracePath, setProcessedTracePath] = useState("");
  const [visualizationJson, setVisualizationJson] = useState(null);
  const [jbmcMethodSig, setJbmcMethodSig] = useState("SnowWhite.indexMax:([I)I");
  const [jbmcUnwind, setJbmcUnwind] = useState(5);
  const [jbmcArrayLength, setJbmcArrayLength] = useState(5);
  const [isLoading, setIsLoading] = useState(false);

  // Project ID is now solely managed via local state based on user input.
  const handleProjectIdChange = (e) => {
    setLocalProjectId(e.target.value);
  };

  // Instrument: Uses the project ID from the input field.
  const handleInstrument = async () => {
    if (!localProjectId) {
      alert("Please enter a Project ID before instrumenting");
      return;
    }
    setIsLoading(true);
    try {
      const response = await fetch(
        `/api/instrument?projectName=${encodeURIComponent(projectName)}&projectId=${encodeURIComponent(localProjectId)}`,
        { method: "POST" }
      );
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Instrumentation failed: ${errorText}`);
      }
      const idText = await response.text();
      setInstrumentId(idText.trim());
      alert("Instrument ID: " + idText);
    } catch (error) {
      alert("Instrumentation failed: " + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Trace: Reads the project ID from the local input.
  const handleTrace = async () => {
    if (!localProjectId) {
      alert("Please enter a Project ID before tracing");
      return;
    }
    if (!instrumentId) {
      alert("No instrumentId set! Please instrument first or enter an ID manually.");
      return;
    }
    setIsLoading(true);
    try {
      const response = await fetch(
        `/api/trace?instrumentId=${encodeURIComponent(instrumentId)}&projectId=${encodeURIComponent(localProjectId)}`,
        { method: "POST" }
      );
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Trace run failed: ${errorText}`);
      }
      const idText = await response.text();
      setTraceId(idText.trim());
      alert("Trace ID: " + idText);
    } catch (error) {
      alert("Trace run failed: " + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Process: Uses the same local project ID.
  const handleProcess = async () => {
    if (!localProjectId) {
      alert("Please enter a Project ID before processing");
      return;
    }
    if (!traceId) {
      alert("No traceId set! Please run trace first or enter an ID manually.");
      return;
    }
    setIsLoading(true);
    try {
      const response = await fetch(
        `/api/process?traceId=${encodeURIComponent(traceId)}&projectId=${encodeURIComponent(localProjectId)}`,
        { method: "POST" }
      );
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Processing failed: ${errorText}`);
      }
      const resultText = await response.text();
      setProcessedTracePath(resultText.trim());
      alert("Processed trace stored locally under ID: " + resultText);
    } catch (error) {
      alert("Processing failed: " + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Visualize: Again, the request uses the project ID from the input.
  const handleVisualize = async () => {
    if (!localProjectId) {
      alert("Please enter a Project ID before visualizing");
      return;
    }
    if (!processedTracePath) {
      alert("No processedTrace path (local ID) set! Please process first or enter an ID manually.");
      return;
    }
    setIsLoading(true);
    try {
      const resp = await fetch(
        `/api/visualize/${encodeURIComponent(processedTracePath)}?projectId=${encodeURIComponent(localProjectId)}`
      );
      if (!resp.ok) {
        const errorText = await resp.text();
        throw new Error(`Visualization failed: ${errorText}`);
      }
      const data = await resp.json();
      setVisualizationJson(data);
      if (onVisualize) {
        onVisualize(data);
      }
      const { default: JsonManager } = await import("./Editor/JsonManager.js");
      setJsonManager(new JsonManager(data));
    } catch (error) {
      alert("Visualization failed: " + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Run JBMC: Uses the project ID from the input field.
  const handleRunJBMC = async () => {
    if (!localProjectId) {
      alert("Please enter a Project ID before running JBMC");
      return;
    }
    if (!instrumentId) {
      alert("You must have an instrumentId set (the same as used for trace).");
      return;
    }
    setIsLoading(true);
    try {
      const params = new URLSearchParams({
        instrumentId: instrumentId,
        methodSignature: jbmcMethodSig,
        unwind: jbmcUnwind,
        maxArray: jbmcArrayLength,
        projectId: localProjectId
      });
      const resp = await fetch(`/api/jbmc/run?${params.toString()}`, { method: 'POST' });
      if (!resp.ok) {
        const errText = await resp.text();
        throw new Error(`JBMC run failed: ${errText}`);
      }
      alert("JBMC run succeeded! Check /api/jbmc/result/<instrumentId> or the UI below.");
    } catch (error) {
      alert("JBMC error: " + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Download visualization JSON
  const handleDownloadJson = () => {
    if (!visualizationJson) return;
    const jsonStr = JSON.stringify(visualizationJson, null, 2);
    const blob = new Blob([jsonStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `visualization-project-${localProjectId}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="modular-actions-container">
      {/* Project ID input field */}
      <div className="form-group project-id-form-group">
        <label>
          Project ID:
          <input
            type="text"
            value={localProjectId}
            onChange={handleProjectIdChange}
            placeholder="Enter project ID"
            className="input-field project-id-field"
            disabled={isLoading}
          />
        </label>
        <button
          onClick={() => window.open('/new-project', '_blank')}
          className="small-button"
          disabled={isLoading}
        >
          New Project
        </button>
      </div>

      {/* Loading indicator */}
      {isLoading && (
        <div className="loading-indicator">
          Processing request...
        </div>
      )}

      {/* Instrument & Trace Section */}
      <CollapsibleSection title="Instrument & Trace" defaultOpen={false}>
        <div className="action-group">
          <button onClick={handleInstrument} disabled={isLoading}>Instrument</button>
          <div className="form-group">
            <label>
              Instrument ID:
              <input
                type="text"
                value={instrumentId}
                onChange={(e) => setInstrumentId(e.target.value)}
                className="input-field"
                disabled={isLoading}
              />
            </label>
          </div>
          <button onClick={handleTrace} disabled={isLoading}>Trace</button>
          <div className="form-group">
            <label>
              Trace ID (local path):
              <input
                type="text"
                value={traceId}
                onChange={(e) => setTraceId(e.target.value)}
                className="input-field"
                disabled={isLoading}
              />
            </label>
          </div>
        </div>
      </CollapsibleSection>

      {/* JBMC Parameters Section */}
      <CollapsibleSection title="JBMC Parameters" defaultOpen={false}>
        <div className="action-group">
          <div className="form-group">
            <label>
              Instrument ID:
              <input
                type="text"
                value={instrumentId}
                onChange={(e) => setInstrumentId(e.target.value)}
                placeholder="e.g. 1234-uuid from instrumentation"
                className="input-field"
                disabled={isLoading}
              />
            </label>
          </div>
          <div className="form-group">
            <label>
              Method Signature:
              <input
                type="text"
                value={jbmcMethodSig}
                onChange={(e) => setJbmcMethodSig(e.target.value)}
                className="input-field"
                disabled={isLoading}
              />
            </label>
          </div>
          <div className="form-group">
            <label>
              Unwind:
              <input
                type="number"
                value={jbmcUnwind}
                onChange={(e) => setJbmcUnwind(Number(e.target.value))}
                className="input-field"
                disabled={isLoading}
              />
            </label>
          </div>
          <div className="form-group">
            <label>
              Max Array Length:
              <input
                type="number"
                value={jbmcArrayLength}
                onChange={(e) => setJbmcArrayLength(Number(e.target.value))}
                className="input-field"
                disabled={isLoading}
              />
            </label>
          </div>
          <button onClick={handleRunJBMC} disabled={isLoading}>Run JBMC</button>
        </div>
      </CollapsibleSection>

      {/* Process & Visualize Section */}
      <CollapsibleSection title="Process & Visualize" defaultOpen={false}>
        <div className="action-group">
          <button onClick={handleProcess} disabled={isLoading}>Process</button>
          <div className="form-group">
            <label>
              Processed Trace Path (local ID):
              <input
                type="text"
                value={processedTracePath}
                onChange={(e) => setProcessedTracePath(e.target.value)}
                className="input-field"
                disabled={isLoading}
              />
            </label>
          </div>
          <button onClick={handleVisualize} disabled={isLoading}>Visualize</button>
          {visualizationJson && (
            <button onClick={handleDownloadJson} className="download-button" disabled={isLoading}>
              Download Visualization JSON
            </button>
          )}
        </div>
      </CollapsibleSection>
    </div>
  );
}

ModularActions.propTypes = {
  projectName: PropTypes.string.isRequired,
  setJsonManager: PropTypes.func.isRequired,
  onVisualize: PropTypes.func,
};

export default ModularActions;===== ./WelcomeScreen.js =====
import React, { useState, useEffect } from "react";
import { v4 as uuidv4 } from "uuid";

/**
 * A redesigned welcome screen for ProRunVis (or any other project).
 * Features:
 *  - Animated background overlay (optional)
 *  - Large neon-styled title
 *  - Reworked project ID input box + new project button
 */
export default function WelcomeScreen() {
  const [typedProjectId, setTypedProjectId] = useState("");

  useEffect(() => {
    // (Optional) Run any side-effects or load data needed before user logs in/opens a project
  }, []);

  const handleOpenProject = () => {
    if (!typedProjectId) {
      alert("Please enter a project ID or choose 'Create New Project'");
      return;
    }
    window.location.href = `/?projectId=${encodeURIComponent(typedProjectId)}`;
  };

  const handleNewProject = () => {
    const newId = uuidv4();
    window.location.href = `/?projectId=${encodeURIComponent(newId)}`;
  };

  return (
    <div className="welcome-screen">
      {/* Animated overlay (for a subtle gradient animation) */}
      <div className="welcome-screen__overlay" />

      <div className="welcome-screen__content">
        <h1 className="welcome-screen__title">ProRunVis</h1>
        <p className="welcome-screen__subtitle">
          Visualize and analyze your Java projects with ease.
        </p>

        <div className="welcome-screen__form">
          <label htmlFor="project-input" className="welcome-screen__label">
            Enter an existing Project ID:
          </label>
          <input
            id="project-input"
            type="text"
            placeholder="e.g. 123e4567"
            value={typedProjectId}
            onChange={(e) => setTypedProjectId(e.target.value)}
            className="welcome-screen__input"
          />

          <div className="welcome-screen__buttons">
            <button onClick={handleOpenProject} className="btn neon">
              Open Project
            </button>
            <button onClick={handleNewProject} className="btn neon-green">
              Create New Project
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}===== ./App.js =====
// In your main App or any place you wish to display it
import React from "react";
import NewWelcomeScreen from "./WelcomeScreen";
import "./Css/App.css"; // if separated

export default function App() {
  return (
    <NewWelcomeScreen />
  );
}===== ./Editor/EditorManager.js =====
import React, { useEffect, useRef, useState } from "react";
import PropTypes from "prop-types";
import EditorInitializer from "./EditorInitializer";
import JsonManager from "./JsonManager";
import * as monaco from "monaco-editor/esm/vs/editor/editor.api";
import loopImage from "../Images/loop.png";
import linkImage from "../Images/link.png";
import outlinkImage from "../Images/outlink.png";
import "../Css/App.css";

function EditorManager({
  displayedFile,
  setActiveAndDisplayed,
  isActiveDisplayed,
  jsonManager,
  activeFunctionIndex,
  setActiveFunctionIndex,
  traceNodeToHighlight,
  setTraceNodeToHighlight,
  onHoverTraceId,
  onLineClick, // callback for line click events
  activeIterationIndices,
  setActiveIterationIndices,
}) {
  // States and refs
  const [jumpNodesIndices, setJumpNodesIndices] = useState([]);
  const [doPositionJump, setDoPositionJump] = useState(false);
  const [jumpPosition, setJumpPosition] = useState(new monaco.Position(0, 0));
  const editorContainerRef = useRef(null);
  const [editor, setEditor] = useState(null);
  const [javaFileContent, setJavaFileContent] = useState("");
  const lineToTraceIdRef = useRef({});

  // Loads text from displayedFile into state
  const loadJavaFile = async () => {
    try {
      if (displayedFile) {
        const text = await displayedFile.text();
        setJavaFileContent(text);
      }
    } catch (error) {
      console.error("Error loading the Java file:", error);
    }
  };

  // --- Highlighting functions (unchanged) ---
  function highlightActive(range) {
    editor.createDecorationsCollection([
      {
        options: { className: "active" },
        range: {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn,
        },
      },
    ]);
  }

  function highlightLink(range, linkOrOutLink) {
    editor.createDecorationsCollection([
      {
        options: { className: "link" },
        range: {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn,
        },
      },
    ]);
    setNodeSymbol(range, linkOrOutLink);
  }

  function highlightLoop(range) {
    editor.createDecorationsCollection([
      {
        options: { className: "loop" },
        range: {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn,
        },
      },
    ]);
    setNodeSymbol(range, "loop");
  }

  function highlightEnd(range) {
    editor.createDecorationsCollection([
      {
        options: { className: "inactive" },
        range: {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn,
        },
      },
    ]);
  }

  function setNodeSymbol(range, symbol) {
    const widgetRight = {
      domNode: (() => {
        const domNode = document.createElement("img");
        if (symbol === "loop") {
          domNode.src = loopImage;
        } else if (symbol === "link") {
          domNode.src = linkImage;
        } else {
          domNode.src = outlinkImage;
        }
        return domNode;
      })(),
      getId() {
        return range.toString();
      },
      getDomNode() {
        return this.domNode;
      },
      getPosition() {
        return {
          lane: monaco.editor.GlyphMarginLane.Right,
          range: {
            startLineNumber: range.startLineNumber,
            startColumn: 1,
            endLineNumber: range.startLineNumber,
            endColumn: 1,
          },
        };
      },
    };

    editor.addGlyphMarginWidget(widgetRight);
    editor.layoutGlyphMarginWidget(widgetRight);
  }

  function placeLinePiece(startLineNumber, symbol) {
    editor.createDecorationsCollection([
      {
        range: new monaco.Range(startLineNumber, 1, startLineNumber, 1),
        options: {
          glyphMarginClassName: symbol,
        },
      },
    ]);
  }

  function iterateLine(range) {
    return new monaco.Range(
      range.startLineNumber + 1,
      0,
      range.endLineNumber + 1,
      0
    );
  }

  function drawLine(ranges) {
    let ongoing = false;
    for (let i = 0; i < ranges.length; i++) {
      if (
        i + 1 < ranges.length &&
        ranges[i].startLineNumber === ranges[i + 1].startLineNumber
      ) {
        continue;
      }
      let startLine = new monaco.Range(
        ranges[i].startLineNumber,
        0,
        ranges[i].startLineNumber + 1,
        0
      );
      let endLine = iterateLine(startLine);
      while (endLine.startLineNumber < ranges[i].endLineNumber) {
        placeLinePiece(endLine.startLineNumber, "line");
        endLine = iterateLine(endLine);
      }
      placeLinePiece(startLine.startLineNumber, ongoing ? "line" : "start");
      startLine = new monaco.Range(
        ranges[i].endLineNumber,
        0,
        ranges[i].endLineNumber + 1,
        0
      );
      endLine = iterateLine(startLine);
      if (i !== ranges.length - 1) {
        while (
          editor.getModel().getValueInRange(endLine).trim().length === 0 &&
          endLine.startLineNumber < ranges[i + 1].startLineNumber
        ) {
          endLine = iterateLine(endLine);
        }
      }
      if (
        i + 1 < ranges.length &&
        endLine.startLineNumber === ranges[i + 1].startLineNumber
      ) {
        if (startLine.startLineNumber === ranges[i].startLineNumber) {
          startLine = iterateLine(startLine);
        }
        while (startLine.startLineNumber < endLine.startLineNumber) {
          placeLinePiece(startLine.startLineNumber, "line");
          startLine = iterateLine(startLine);
        }
        ongoing = true;
      } else {
        placeLinePiece(ranges[i].endLineNumber, ongoing ? "end" : "one-line");
        ongoing = false;
      }
    }
  }

  function changeIteration(newIterationIndex) {
    setActiveIterationIndices([newIterationIndex]);
  }

  // NEW: Register an onMouseDown listener that logs the event and calls onLineClick.
  useEffect(() => {
    if (editor && onLineClick) {
      const disposable = editor.onMouseDown((e) => {
        if (!e.target || !e.target.position) return;
        const lineNumber = e.target.position.lineNumber;
        const fileName = displayedFile ? displayedFile.name : "UnknownFile.java";
        console.log("EditorManager: onMouseDown event:", e);
        console.log(`EditorManager: Click detected on file ${fileName} at line ${lineNumber}`);
        // Call the callback passed from the parent
        onLineClick(fileName, lineNumber);
      });
      return () => disposable.dispose();
    }
  }, [editor, onLineClick, displayedFile]);

  // (Keep your other event listeners such as handleJumps and handleIterationButton as-is)
  function handleJumps() {
    editor.onMouseDown((e) => {
      if (!e.target || !e.target.position) return;
      const position = e.target.position;
      jumpNodesIndices.forEach((jumpIndex) => {
        if (jumpIndex === 1) return;
        const jump = jsonManager.nodes[jumpIndex];
        if (jump.nodeType !== "Function" || jumpIndex === activeFunctionIndex) {
          if (jump.nodeType === "Function" && jump.outLinks.length === 2) {
            if (jump.outLinks[1].range.containsPosition(position)) {
              setJumpPosition(jump.outLinkPosition);
              setDoPositionJump(true);
              setActiveIterationIndices(jump.outLoopIterations);
              setActiveFunctionIndex(jump.outFunctionIndex);
            }
            jsonManager
              .updateActiveRangesFunction(activeFunctionIndex, activeIterationIndices)
              .forEach((range) => {
                if (range.containsRange(jsonManager.nodes[jumpIndex].outLinks[0].range)) {
                  if (jump.outLinks[0].range.containsPosition(position)) {
                    setJumpPosition(jump.outLinkPosition);
                    setDoPositionJump(true);
                    setActiveIterationIndices(jump.outLoopIterations);
                    setActiveFunctionIndex(jump.outFunctionIndex);
                  }
                }
              });
          } else {
            jump.outLinks.forEach((outLink) => {
              if (outLink.range.containsPosition(position)) {
                setJumpPosition(jump.outLinkPosition);
                setDoPositionJump(true);
                setActiveIterationIndices(jump.outLoopIterations);
                setActiveFunctionIndex(jump.outFunctionIndex);
              }
            });
          }
        }
        if (jumpIndex === activeFunctionIndex) return;
        if (jump.nodeType === "Function") {
          if (jump.link.range.containsPosition(position)) {
            setJumpPosition(jump.linkPosition);
            setDoPositionJump(true);
            setActiveIterationIndices(jsonManager.initIterations(jumpIndex, []));
            setActiveFunctionIndex(jumpIndex);
          }
        }
      });
    });
  }

  function handleIterationButton() {
    editor.onMouseDown((e) => {
      if (!e.target || !e.target.position) return;
      const position = e.target.position;
      activeIterationIndices.forEach((iterationIndex) => {
        const iteration = jsonManager.nodes[iterationIndex];
        if (iteration.link.range.containsPosition(position)) {
          const baseId = JsonManager.getBaseTraceId(iteration.traceId);
          let nextIteration = prompt("Please enter the iteration", iteration.iteration);
          nextIteration = parseInt(nextIteration, 10);
          for (let i = 0; i < jsonManager.nodes.length; i++) {
            const node = jsonManager.nodes[i];
            const candidateBaseId = JsonManager.getBaseTraceId(node.traceId);
            if (
              candidateBaseId === baseId &&
              node.iteration === nextIteration &&
              node.parentIndex === iteration.parentIndex
            ) {
              changeIteration(i);
              break;
            }
          }
        }
      });
    });
  }

  function splitRangeByLine(range) {
    if (!editor) return [range];
    const result = [];
    const model = editor.getModel();
    if (!model) return [range];
    const startLineNumber = range.startLineNumber;
    const endLineNumber = range.endLineNumber;
    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      const firstNonWhitespace = lineContent.search(/\S/);
      const startColumn =
        lineNumber === startLineNumber
          ? range.startColumn
          : Math.max(1, firstNonWhitespace + 1);
      const endColumn =
        lineNumber === endLineNumber
          ? range.endColumn
          : model.getLineMaxColumn(lineNumber);
      result.push(new monaco.Range(lineNumber, startColumn, lineNumber, endColumn));
    }
    return result;
  }

  function jumpToPosition(position) {
    if (!position || !editor) return;
    editor.revealLineNearTop(position.lineNumber);
    editor.setPosition(position);
  }

  useEffect(() => {
    if (traceNodeToHighlight && editor) {
      if (traceNodeToHighlight.link && traceNodeToHighlight.link.range) {
        jumpToPosition(traceNodeToHighlight.link.range.getStartPosition());
        highlightActive(traceNodeToHighlight.link.range);
      }
    }
  }, [traceNodeToHighlight, editor]);

  useEffect(() => {
    if (editor) {
      const subscription = editor.onMouseMove((e) => {
        if (!e.target || !e.target.position) {
          onHoverTraceId && onHoverTraceId(null);
          return;
        }
        const line = e.target.position.lineNumber;
        const traceIds = lineToTraceIdRef.current[line];
        if (Array.isArray(traceIds) && traceIds.length > 0) {
          if (activeIterationIndices.length > 0) {
            const activeIterIndex = activeIterationIndices[0];
            const activeIterNode = jsonManager.nodes[activeIterIndex];
            if (!activeIterNode) {
              onHoverTraceId && onHoverTraceId(traceIds[0]);
              return;
            }
            const activeTraceId = activeIterNode.traceId;
            if (traceIds.includes(activeTraceId)) {
              onHoverTraceId && onHoverTraceId(activeTraceId);
            } else {
              onHoverTraceId && onHoverTraceId(traceIds[0]);
            }
          } else {
            onHoverTraceId && onHoverTraceId(traceIds[0]);
          }
        } else {
          onHoverTraceId && onHoverTraceId(null);
        }
      });
      return () => subscription.dispose();
    }
  }, [editor, onHoverTraceId, activeIterationIndices, jsonManager]);

  useEffect(() => {
    if (jsonManager) {
      setActiveFunctionIndex(jsonManager.getMain());
      setActiveAndDisplayed(jsonManager.nodes[1].link.file);
      setActiveIterationIndices(jsonManager.initIterations(1, []));
    }
  }, [jsonManager]);

  useEffect(() => {
    if (displayedFile) {
      loadJavaFile();
    }
  }, [displayedFile]);

  useEffect(() => {
    let newEditor;
    if (javaFileContent && editorContainerRef.current) {
      let hints = [];
      if (isActiveDisplayed()) {
        activeIterationIndices.forEach((iterationIndex) => {
          const position = jsonManager.nodes[iterationIndex].link.range.getStartPosition();
          const content =
            "(" +
            jsonManager.nodes[iterationIndex].iteration +
            "/" +
            jsonManager.getLastIterationNumber(iterationIndex) +
            ")";
          hints.push({ position, content });
        });
      }
      if (editor) {
        editor.dispose();
      }
      newEditor = EditorInitializer.initializeEditor(
        editorContainerRef,
        javaFileContent,
        hints
      );
      if (newEditor) {
        setEditor(newEditor.editor);
      }
    }
    return () => {
      if (javaFileContent && editorContainerRef.current && newEditor) {
        newEditor.dispose();
      }
    };
  }, [javaFileContent, activeIterationIndices, activeFunctionIndex]);

  useEffect(() => {
    if (jsonManager) {
      setActiveAndDisplayed(jsonManager.nodes[activeFunctionIndex].link.file);
    }
  }, [activeFunctionIndex]);

  useEffect(() => {
    if (jsonManager) {
      setJumpNodesIndices(
        jsonManager.updateJumpsFunction(activeFunctionIndex, activeIterationIndices)
      );
    }
  }, [activeIterationIndices]);

  useEffect(() => {
    if (jsonManager && editor) {
      const rangesToHighlight = jsonManager.updateActiveRangesFunction(
        activeFunctionIndex,
        activeIterationIndices
      );
      if (isActiveDisplayed()) {
        setDoPositionJump(true);
        rangesToHighlight.forEach((rangeToHighlight) => {
          splitRangeByLine(rangeToHighlight).forEach((splitRangeToHighlight) => {
            highlightActive(splitRangeToHighlight);
          });
        });
        drawLine(rangesToHighlight);
        jumpNodesIndices.forEach((jumpIndex) => {
          const jNode = jsonManager.nodes[jumpIndex];
          if (jNode.nodeType !== "Function" || jumpIndex === activeFunctionIndex) {
            if (jNode.nodeType === "Function" && jNode.outLinks.length === 2) {
              highlightLink(jNode.outLinks[1].range);
              jsonManager
                .updateActiveRangesFunction(activeFunctionIndex, activeIterationIndices)
                .forEach((range) => {
                  if (range.containsRange(jNode.outLinks[0].range)) {
                    highlightLink(jNode.outLinks[0].range, "outlink");
                  }
                });
            } else {
              jNode.outLinks.forEach((outLink) => {
                highlightLink(outLink.range, "outlink");
              });
            }
          }
          if (jumpIndex !== activeFunctionIndex && jNode.nodeType === "Function") {
            highlightLink(jNode.link.range, "link");
          }
        });
        handleJumps();
        handleIterationButton();
        activeIterationIndices.forEach((index) => {
          highlightLoop(jsonManager.nodes[index].link.range);
        });
      }
      if (!doPositionJump && isActiveDisplayed()) {
        if (activeFunctionIndex !== 1) {
          jumpToPosition(
            jsonManager.nodes[activeFunctionIndex].outLinks[
              jsonManager.nodes[activeFunctionIndex].outLinks.length - 1
            ].range.getStartPosition()
          );
        } else {
          jumpToPosition(
            jsonManager.nodes[activeFunctionIndex].link.range.getStartPosition()
          );
        }
        setDoPositionJump(false);
      }
      if (doPositionJump) {
        setDoPositionJump(false);
        jumpToPosition(jumpPosition);
      }
    }
  }, [editor]);

  useEffect(() => {
    if (!jsonManager || !jsonManager.nodes) return;
    lineToTraceIdRef.current = {};
    jsonManager.nodes.forEach((node) => {
      if (!node.traceId || !node.ranges || node.ranges.length === 0) return;
      node.ranges.forEach((rng) => {
        for (let ln = rng.startLineNumber; ln <= rng.endLineNumber; ln++) {
          if (!lineToTraceIdRef.current[ln]) {
            lineToTraceIdRef.current[ln] = [];
          }
          lineToTraceIdRef.current[ln].push(node.traceId);
        }
      });
    });
    console.log("Built line->traceId map:", lineToTraceIdRef.current);
  }, [jsonManager]);

  return (
    <main className="right-container">
      <div ref={editorContainerRef} className="editor-container"></div>
    </main>
  );
}

EditorManager.propTypes = {
  displayedFile: PropTypes.instanceOf(File),
  setActiveAndDisplayed: PropTypes.func,
  activeFunctionIndex: PropTypes.number,
  setActiveFunctionIndex: PropTypes.func,
  traceNodeToHighlight: PropTypes.object,
  setTraceNodeToHighlight: PropTypes.func,
  onHoverTraceId: PropTypes.func,
  isActiveDisplayed: PropTypes.func,
  jsonManager: PropTypes.instanceOf(JsonManager),
  activeIterationIndices: PropTypes.array.isRequired,
  setActiveIterationIndices: PropTypes.func.isRequired,
  onLineClick: PropTypes.func, // NEW: prop for line click events
};

export default EditorManager;===== ./Editor/JsonManager.js =====
import TraceNode from "./TraceNode";
import { editor, Position } from "monaco-editor";

/**
 * Helper function to extract the base trace ID from a full traceId.
 * If the traceId contains "_iter", this function returns only the part before it.
 * Otherwise, it returns the entire traceId.
 * @param {string} traceId
 * @returns {string}
 */
/**
 * Returns the substring before "_iter".
 * If no "_iter" is found, returns the entire traceId.
 *
 * @param {string} traceId e.g. "loop42_iter3" or "loop42"
 * @returns {string} the base ID, e.g. "loop42"
 */

/**
 * Class that contains an array of {@link TraceNode}s and manages them.
 * It provides functions to extract information needed for the editor.
 */
class JsonManager {
  /**
   * Constructor takes in a JSON string, maps the data to {@link TraceNode}s,
   * and saves them in an array.
   * @param {string} jsonString - JSON data from the backend.
   */
  constructor(jsonString) {
    this.nodes = [];
    this.activeIterations = [];
    this.skipIds = [];
    this.activeIterationIndex = 0;
    let data = jsonString;
    data.forEach((jsonData) => {
      this.nodes.push(new TraceNode(jsonData));
    });
    for (let i = 2; i < this.nodes.length; i++) {
      let node = this.nodes[i];
      if (node.nodeType === "Throw") {
        node.outLinkPosition = new Position(0, 0);
        if (this.nodes[node.outIndex].ranges.length !== 0) {
          // If catch is empty and has no range, pick the first sorted range.
          node.outLinkPosition = this.nodes[node.outIndex].ranges
            .sort((a, b) =>
              a.startLineNumber < b.startLineNumber ? -1 : a.startLineNumber > b.startLineNumber ? 1 : 0
            )[0].getStartPosition();
        }
      }
      if (node.nodeType === "Function") {
        node.linkPosition = node.outLinks[node.outLinks.length - 1].range.getStartPosition();
        node.outLinkPosition = node.link.range.getStartPosition();
      }
      if (node.nodeType === "Function" || node.nodeType === "Throw") {
        let currentIndex = node.outIndex;
        let currentNode = this.nodes[currentIndex];
        let parentBeforeIndex = -1;
        let parentBeforeTraceId = -1;
        let iterationsBefore = [];
        let iterations = [];
        let start = true;
        while (currentNode.nodeType !== "Function" || start) {
          if (!start) {
            currentIndex = this.nodes[currentIndex].parentIndex;
            currentNode = this.nodes[currentIndex];
            parentBeforeTraceId = this.nodes[parentBeforeIndex].traceId;
          }
          iterations = [];
          if (currentNode.nodeType === "Loop") {
            iterations.push(currentIndex);
          }
          currentNode.childrenIndices.forEach((childIndex) => {
            if (childIndex === parentBeforeIndex) {
              iterations.push(...iterationsBefore);
            } else if (this.nodes[childIndex].iteration === 1 &&
                       this.nodes[childIndex].traceId !== parentBeforeTraceId) {
              iterations.push(childIndex);
            }
          });
          parentBeforeIndex = currentIndex;
          iterationsBefore = iterations;
          start = false;
        }
        this.nodes[i].outLoopIterations = iterations;
        this.nodes[i].outFunctionIndex = currentIndex;
      }
    }
  }

  /**
   * Returns the index of the main function in nodes.
   * @returns {number}
   */
  getMain() {
    return 1;
  }

  /**
   * Returns the parent function index for a given node.
   * @param {number} nodeIndex
   * @returns {number}
   */
  getParentFunction(nodeIndex) {
    if (nodeIndex < 1 || nodeIndex > this.nodes.length - 1) return -1;
    let currentIndex = nodeIndex;
    let currentNode = this.nodes[currentIndex];
    while (currentNode.nodeType !== "Function") {
      currentIndex = currentNode.parentIndex;
      currentNode = this.nodes[currentIndex];
    }
    return currentIndex;
  }

  /**
     * Returns the base trace ID by stripping out the "_iter" suffix.
     * @param {string} traceId
     * @returns {string} the base trace ID.
     */
    static getBaseTraceId(traceId) {
      const index = traceId.indexOf("_iter");
      return index === -1 ? traceId : traceId.substring(0, index);
    }


  /**
   * Returns the number of the last iteration that belongs to the loop.
   * This method compares only the base trace IDs (before "_iter").
   * @param {number} iterationIndex - Index of a TraceNode representing one iteration.
   * @returns {number} The highest iteration number found.
   */
getLastIterationNumber(iterationIndex) {
  let iterationIndexId = this.nodes[iterationIndex].traceId;
  // Use the static method on JsonManager
  let baseId = JsonManager.getBaseTraceId(iterationIndexId);
  let lastIteration = this.nodes[iterationIndex].iteration;

  this.nodes[this.nodes[iterationIndex].parentIndex].childrenIndices.forEach((childIndex) => {
    if (
      JsonManager.getBaseTraceId(this.nodes[childIndex].traceId) === baseId &&
      this.nodes[childIndex].iteration > lastIteration
    ) {
      lastIteration = this.nodes[childIndex].iteration;
    }
  });
  return lastIteration;
}

  /**
   * Determines the initially active iterations for a function.
   * @param {number} functionIndex - Index of the currently active function.
   * @param {Array} activeIterationIndices - Current active iteration indices.
   * @returns {Array} An array with the active iteration node indices.
   */
  initIterations(functionIndex, activeIterationIndices) {
    this.skipIds = [];
    this.activeIterations = [...activeIterationIndices];
    this.activeIterationIndex = 0;
    this.nodes[functionIndex].childrenIndices.forEach((childIndex) => {
      this.getIterations(childIndex);
    });
    return this.activeIterations;
  }

  /**
   * Recursively determines all active loops that have this node as a grandparent.
   * @param {number} nodeIndex - Current node index.
   * @returns {Array} An array with the active iteration indices.
   */
  getIterations(nodeIndex) {
    let end = false;
    this.skipIds.forEach((skipId) => {
      if (this.nodes[nodeIndex].traceId === skipId) {
        end = true;
      }
    });
    if (end || this.nodes[nodeIndex].nodeType === "Function") {
      return [];
    }
    let skip = true;
    if (this.nodes[nodeIndex].nodeType !== "Loop") skip = false;
    if (this.activeIterationIndex + 1 > this.activeIterations.length && this.nodes[nodeIndex].iteration === 1) {
      this.activeIterations.push(nodeIndex);
      this.activeIterationIndex++;
      skip = false;
      this.skipIds.push(this.nodes[nodeIndex].traceId);
    }
    if (
      !(this.activeIterationIndex + 1 > this.activeIterations.length) &&
      this.nodes[nodeIndex].iteration === this.nodes[this.activeIterations[this.activeIterationIndex]].iteration
    ) {
      this.activeIterationIndex++;
      this.skipIds.push(this.nodes[nodeIndex].traceId);
      skip = false;
    }
    if (!skip) {
      this.nodes[nodeIndex].childrenIndices.forEach((childIndex) => {
        this.activeIterations.concat(this.getIterations(childIndex));
      });
    }
  }

  /**
   * Determines all function and throw nodes in the currently active function,
   * marking whether they are active based on the active iterations.
   * @param {number} functionIndex - Index of the active function.
   * @param {Array} activeIterationIndices - Current active loop iterations.
   * @returns {Array} An array with indices of the function or throw nodes.
   */
  updateJumpsFunction(functionIndex, activeIterationIndices) {
    this.skipIds = [];
    this.activeIterations = [...activeIterationIndices];
    let jumps = [];
    jumps.push(functionIndex);
    this.nodes[functionIndex].childrenIndices.forEach((childIndex) => {
      jumps = jumps.concat(this.getJumps(childIndex));
    });
    return jumps;
  }

  /**
   * Recursively determines all function and throw nodes that are part of the current function.
   * @param {number} nodeIndex - Current node index.
   * @returns {Array} An array with indices of the function or throw nodes.
   */
  getJumps(nodeIndex) {
    let jumps = [];
    let end = false;
    this.skipIds.forEach((skipId) => {
      if (this.nodes[nodeIndex].traceId === skipId) end = true;
    });
    if (end) return jumps;
    if (this.nodes[nodeIndex].nodeType === "Function" || this.nodes[nodeIndex].nodeType === "Throw")
      jumps.push(nodeIndex);
    if (
      (!(this.nodes[nodeIndex].nodeType === "Loop") ||
        nodeIndex === this.activeIterations[0])
    ) {
      if (this.nodes[nodeIndex].nodeType === "Loop") {
        this.activeIterations.shift();
        this.skipIds.push(this.nodes[nodeIndex].traceId);
      }
      if (this.nodes[nodeIndex].nodeType !== "Function") {
        this.nodes[nodeIndex].childrenIndices.forEach((childIndex) => {
          jumps = jumps.concat(this.getJumps(childIndex));
        });
      }
    }
    return jumps;
  }

  /**
   * Determines all active ranges in the currently active function.
   * @param {number} functionIndex - Index of the active function.
   * @param {Array} activeIterationIndices - Active loop iterations.
   * @returns {Array} An array with all active ranges.
   */
  updateActiveRangesFunction(functionIndex, activeIterationIndices) {
    let ranges = [];
    this.activeIterations = [...activeIterationIndices];
    this.skipIds = [];
    this.nodes[functionIndex].ranges.forEach((range) => {
      ranges.push(range);
    });
    this.nodes[functionIndex].childrenIndices.forEach((childIndex) => {
      ranges = ranges.concat(this.getActiveRanges(childIndex));
    });
    ranges.sort((a, b) =>
      a.startLineNumber < b.startLineNumber ? -1 : a.startLineNumber > b.startLineNumber ? 1 : 0
    );
    return ranges;
  }

  /**
   * Recursively determines all ranges of all child nodes that are part of the current function.
   * @param {number} nodeIndex - Current node index.
   * @returns {Array} An array with the ranges for the node and its children.
   */
  getActiveRanges(nodeIndex) {
    let ranges = [];
    let end = false;
    this.skipIds.forEach((skipId) => {
      if (this.nodes[nodeIndex].traceId === skipId) end = true;
    });
    if (end) return ranges;
    if (this.nodes[nodeIndex].nodeType === "Function") {
      ranges.push(this.nodes[nodeIndex].link.range);
    } else if (
      this.nodes[nodeIndex].nodeType !== "Loop" ||
      nodeIndex === this.activeIterations[0]
    ) {
      if (this.nodes[nodeIndex].nodeType === "Loop") {
        this.activeIterations.shift();
        this.skipIds.push(this.nodes[nodeIndex].traceId);
      }
      this.nodes[nodeIndex].ranges.forEach((range) => {
        ranges.push(range);
      });
      this.nodes[nodeIndex].childrenIndices.forEach((childIndex) => {
        ranges = ranges.concat(this.getActiveRanges(childIndex));
      });
    }
    return ranges;
  }
}

export default JsonManager;===== ./Editor/TraceNode.js =====

/**
 * TracNode class that stores the information of a traced node from tha backend.
 * ranges: Array of all executed {@link monaco.Range}s contained in this node.
 * childrenIndices: Array of all children indices associated with this node.
 * parentIndex: Index of the parent of this node. Null for root node.
 *      For Loop iterations always set to node of first iteration.
 * link: {@link SourceRange} that contains {@link monaco.Range} of link that can be clicked
 *      and relative filepath it leads to. Only set for Function and Loop nodes, otherwise null.
 *      For main function set range is set to method head and file that contains it.
 * outLinks: Array of maximum two {@link SourceRange}s. For Functions function name and if there taken return statement.
 *      For Throws one {@link SourceRange} with range of throw statement. Null for main function.
 * outIndex: Index of parent node the outLink leads back to.
 * iteration: Number of the iteration. Set for Loops otherwise null.
 * c
 * Loop iterations of the same loop have the same traceId.
 * nodeType: String set to "Loop", "Function", "Throw" or "Other"
 *  The following attributes are initially set to null,
 *  but after creation of all TraceNodes assigned in {@link JsonManager},
 *  because they partly depend on other TraceNodes.
 * linkPosition: {@link monaco.Position} the link leads to.
 * outLinkPosition: {@link monaco.Position} both outLinks leads to.
 * outFunctionIndex: Index of the function that contains the node that both outLinks lead to.
 * outLoopIterations: Iterations that are set in the outFunction were the node both outLinks lead to got executed.
 */
class TraceNode {
    /**
     * Maps given json data from the backend onto an instance of this class and extend it with additional information.
     * @param node json data node.
     */
    constructor(node) {
        //ranges: Array of all executed {@link monaco.Range}s contained in this node.

        this.ranges = [];
        if (node.ranges !== undefined)
            node.ranges.forEach((range) => {
                this.ranges.push(new monaco.Range(
                    range.begin.line, range.begin.column, range.end.line, range.end.column + 1));
            });

        //childrenIndices: Array of all children indices associated with this node.
        this.childrenIndices = [];
        if (node.childrenIndices !== undefined)
            node.childrenIndices.forEach((childIndex) => {
                this.childrenIndices.push(childIndex);
            });
        //parentIndex: Index of the parent of this node. Null for root node.
        //      For Loop iterations always set to node of first iteration.
        this.parentIndex = null;
        if (node.parentIndex !== undefined)
            this.parentIndex = node.parentIndex;

        //link: {@link SourceRange} that contains {@link monaco.Range} of link that can be clicked
        //      and relative filepath it leads to. Only set for Function and Loop nodes, otherwise null.
        //      For main function set range is set to method head and file that contains it.
        this.link = null;
        if (node.link !== undefined)
            this.link = new SourceRange(
                new monaco.Range(
                    node.link.begin.line,
                    node.link.begin.column,
                    node.link.end.line,
                    node.link.end.column + 1),
                node.link.filepath);

        //outLinks: Array of maximum two {@link SourceRange}s. For Functions function name and if there taken return statement.
        //      For Throws one {@link SourceRange} with range of throw statement. Null for main function.
        this.outLinks = [];
        if (node.outLinks !== undefined)
            node.outLinks.forEach((nodeOutLink) => {
                this.outLinks.push(new SourceRange(
                    new monaco.Range(
                        nodeOutLink.begin.line,
                        nodeOutLink.begin.column,
                        nodeOutLink.end.line,
                        nodeOutLink.end.column + 1),
                    nodeOutLink.filepath));
            });

        //outIndex: Index of parent node the outLink leads back to.
        this.outIndex = null;
        if (node.outIndex !== undefined && node.outIndex !== 0)
            this.outIndex = node.outIndex;

        //iteration: Number of the iteration. Set for Loops otherwise null.
        this.iteration = null;
        if (node.iteration !== undefined)
            this.iteration = node.iteration;

        //traceId: Unique id that can be used to map each TraceNode to its code block.
        //      Loop iterations of the same loop have the same traceId.
        this.traceId = null;
if (node.traceId !== undefined) {
  // Overwrite 'this.traceId' to always store the iteration-based ID
  if (this.iteration != null && this.iteration > 0) {
    this.traceId = node.traceId + "_iter" + this.iteration;
  } else {
    this.traceId = node.traceId;
  }
} else {
  this.traceId = null;
}
        //nodeType: String set to "Loop", "Function", "Throw" or "Other"
        this.nodeType = "Other";
        if (this.iteration != null) {
            this.nodeType = "Loop";
        } else if (this.link != null) {
            this.nodeType = "Function";
        } else if (this.outIndex != null) {
            this.nodeType = "Throw";
        }
         this.nodeMethodName = node.nodeMethodName || null;
        //----The following attributes are initially set to null.----
        //  After creation of all TraceNodes assigned in {@link JsonManager},
        //  because they partly depend on other TraceNodes.

        //linkPosition: {@link monaco.Position} the link leads to.
        this.linkPosition = null;
        //outLinkPosition: {@link monaco.Position} both outLinks leads to.
        this.outLinkPosition = null;
        //outFunctionIndex: Index of the function that contains the node that both outLinks lead to.
        this.outFunctionIndex = null;
        //outLoopIterations: Iterations that are set in the outFunction were the node both outLinks lead to got executed.
        this.outLoopIterations = [];
    }
}

export default TraceNode;

/**
 * Container that links a monaco.Range and a relative file path together. Used for links.
 */
class SourceRange {
    /**
     * Creates an instance of this class.
     * @param range monaco.Range.
     * @param filepath string of a relative file path.
     */
    constructor(range, filepath) {
        this.range = range;
        this.file = filepath;
    }
}
===== ./Editor/EditorInitializer.js =====
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';

/**
 * Initializes the Monaco Editor with specific settings for editing Java files.
 * This class provides static methods to configure the editor, including setting
 * up the theme, syntax highlighting, and adjusting the editor's height based on its content.
 * It also demonstrates how to use Monaco Editor's API to create a more interactive
 * and user-friendly code editor environment.
 */
export class EditorInitializer {

    /**
     * Initializes the Monaco Editor in the provided container with the given Java file content.
     * This method sets up the editor with predefined options such as language, theme, and various
     * editor behaviors like word wrapping and automatic layout adjustments. It also defines a custom
     * theme and syntax highlighting rules specifically tailored for Java code.
     *
     * @param containerRef A reference to the container DOM element where the editor will be instantiated.
     * @param javaFileContent The initial Java code content to be loaded into the editor.
     * @param hints list of InlayHints(monaco editor) to display in the editor.
     * @return The initialized Monaco Editor instance, or undefined if initialization fails.
     */
    static initializeEditor(containerRef, javaFileContent, hints) {
        if (typeof javaFileContent !== 'string') {
            console.error('javaFileContent must be a string');
            return;
        }
        if (!containerRef.current) {
            return;
        }
        const editor = monaco.editor.create(containerRef.current, {  // Creates a new editor
            value: javaFileContent,
            language: 'java',
            theme: 'java-theme',
            glyphMargin: true,
            scrollBeyondLastLine: false,
            minimap: {enabled: false},
            wordWrap: 'off',
            readOnly: true,
            automaticLayout: true,
            scrollbar: {
                alwaysConsumeMouseWheel: true
            },
        });

        // ----------------------------------Syntax Highlighting ------------------------------------


        monaco.editor.defineTheme('java-theme', {  // Style Properties of the editor
            base: 'vs-dark',
            inherit: true,
            rules: [
                {token: 'keyword', foreground: '569CD6', fontStyle: 'bold'},
                {token: 'number', foreground: 'B5CEA8'},
                {token: 'type', foreground: '4EC9B0'},
                {token: 'string', foreground: 'CE9178'},
                {token: 'comment', foreground: '6A9955'},
                {token: 'annotation', foreground: 'B8860B'},
                {token: 'operator', foreground: 'D4D4D4'},
                {token: 'delimiter', foreground: 'D4D4D4'},
                {token: 'namespace', foreground: '4EC9B0'},
                {token: 'custom-system-out', foreground: 'FFA500'},
                {token: 'custom-wrapper-class', foreground: 'FF4500'},
                {token: 'custom-exception-class', foreground: 'FF0000'},
            ],
            colors: {
                'editor.foreground': '#D4D4D4',
                'editor.background': '#1E1E1E',
                'editorCursor.foreground': '#A7A7A7',
                'editor.lineHighlightBackground': '#2D2D30',
                'editorLineNumber.foreground': '#858585',
                'editor.selectionBackground': '#264F78',
                'editor.inactiveSelectionBackground': '#3A3D41',
            }
        });

        monaco.languages.setMonarchTokensProvider('java', {   // Syntax highlighting
            tokenizer: {
                root: [
                    [/\b(Integer|Double|Float|Long|Short|Byte|Boolean|Character|String)\b/, 'custom-wrapper-class'],
                    [/\b(Exception|RuntimeException|Error|Throwable|IOException|NullPointerException|ArrayIndexOutOfBoundsException|ClassCastException|NumberFormatException)\b/, 'custom-exception-class'],
                    [/\bSystem\.out\.[a-zA-Z]+\b/, 'custom-system-out'],
                    [/public|private|protected/, 'keyword'],
                    [/\b(class|interface|enum|extends|implements|volatile|synchronized|abstract|final|static|void|boolean|byte|char|short|int|float|long|double)\b/, 'keyword'],
                    [/\b(package|import)\b/, 'keyword'],
                    [/\b(return|if|else|while|for|break|continue|do|switch|case|default)\b/, 'keyword'],
                    [/\b(try|catch|finally|throw|throws)\b/, 'keyword'],
                    [/\b(new|this|super)\b/, 'keyword'],
                    [/\b(instanceof)\b/, 'keyword'],
                    [/\b(true|false|null)\b/, 'literal'],
                    [/\b(System\.out\.println)\b/, 'custom-function'],
                    [/\b([A-Za-z_]\w*)\b/, 'identifier'],
                    [/"([^"\\]|\\.)*"/, 'string'],
                    [/'([^'\\]|\\.)*'/, 'string'],
                    [/\b\d+\.?\d*\b/, 'number'],
                    [/\/\/.*$/, 'comment'],
                    [/\/\*/, {token: 'comment', next: '@comment'}],
                    [/[[\](){}<>]/, 'delimiter'],
                    [/[;,.]/, 'delimiter'],
                    [/[+\-*/=<>!&|~^%]/, 'operator']
                ],
                comment: [
                    [/[^/*]+/, 'comment'],
                    [/\*\//, 'comment', '@pop'],
                    [/[/*]/, 'comment']
                ],
            }
        });

        // ----------------------------------Loop Indices ------------------------------------
        const {dispose} = monaco.languages.registerInlayHintsProvider("java", {
            provideInlayHints(model, range, token) {
                let newHints = [];
                hints.forEach((hint) => {
                    newHints.push({
                        kind: monaco.languages.InlayHintKind.Parameter,
                        position: {column: hint.position.column, lineNumber: hint.position.lineNumber},
                        label: hint.content,
                    });
                });
                return {
                    hints: newHints,
                    dispose: () => {
                    },
                };
            },
        });

        //Sets up a monaco worker environment (uses the default provided by monaco).
        window.MonacoEnvironment = {
            getWorkerUrl: function (moduleId, label) {
                return `data:text/javascript;charset=utf-8,${encodeURIComponent(`
            self.MonacoEnvironment = {
                baseUrl: ''
            };

            self.onmessage = function (e) {
                // Handle message received from the main thread
            };
        `)}`;
            }
        };

        monaco.languages.register({id: 'java'});   // Activates the syntax highlighting

        // -------------------------------------  All other function calls for the editor  ----------------------------

        // Update the content
        editor.getModel().setValue(javaFileContent);

        // Set dark theme
        monaco.editor.setTheme('vs-dark');

        return {editor, dispose};
    }
}

export default EditorInitializer;===== ./WebsiteContainer.js =====
// WebsiteContainer.js
import React, { useState, useEffect } from "react";
import DirectoryBar from "./WebsiteElements/DirectoryBar";
import EditorManager from "./Editor/EditorManager";
import JsonManager from "./Editor/JsonManager";
import ModularActions from "./ModularActions";
import JsonViewer from "./WebsiteElements/JsonViewer";
import TraceTree from "./WebsiteElements/TraceTree";
import MethodTreeView from "./WebsiteElements/MethodTreeView";
import CollapsibleSection from "./WebsiteElements/CollapsibleSection";
import MergedAssignmentsTable from "./WebsiteElements/MergedAssignmentsTable";
import "./Css/App.css";

function WebsiteContainer() {
  // Basic state management
  const [displayedFile, setDisplayedFile] = useState(null);
  const [activeFile, setActiveFile] = useState(null);
  const [jsonManager, setJsonManager] = useState(null);
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [visualizationJson, setVisualizationJson] = useState(null);
  const [staticMethodsJson, setStaticMethodsJson] = useState(null);
  const [activeFunctionIndex, setActiveFunctionIndex] = useState(1);
  const [viewerMode, setViewerMode] = useState("JSON");
  const [traceNodeToHighlight, setTraceNodeToHighlight] = useState(null);
  const [hoveredTraceId, setHoveredTraceId] = useState(null);
  const [activeIterationIndices, setActiveIterationIndices] = useState([]);
  const [selectedVariable, setSelectedVariable] = useState(null);
  const [jbmcJson, setJbmcJson] = useState(null);
  const [instrumentId, setInstrumentId] = useState("");
  const [isMiddleContainerCollapsed, setIsMiddleContainerCollapsed] = useState(false);

  // Project ID state used for file upload and variable mapping in DirectoryBar
  const [projectId, setProjectId] = useState(() => {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get("projectId") || "";
  });

  // On mount, check URL for an existing projectId
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const urlProjectId = urlParams.get("projectId");
    if (urlProjectId) {
      setProjectId(urlProjectId);
      console.log(`Using Project ID from URL: ${urlProjectId}`);
    }
  }, []);

  // Whenever projectId changes, update the URL for consistency
  useEffect(() => {
    if (projectId) {
      const url = new URL(window.location);
      url.searchParams.set("projectId", projectId);
      window.history.pushState({}, "", url);
    }
  }, [projectId]);

  // Helper: Switch displayed file to match a given path
  function setActiveAndDisplayed(path) {
    uploadedFiles.forEach((file) => {
      if (path === file.webkitRelativePath) {
        setDisplayedFile(file);
        setActiveFile(file);
      }
    });
  }
  function setDisplayedToActive() {
    setDisplayedFile(activeFile);
  }
  function isActiveDisplayed() {
    return activeFile && displayedFile ? activeFile === displayedFile : false;
  }

  // Called by DirectoryBar after user picks a folder
  async function passOnUploadedFiles(files) {
    setUploadedFiles(files);

    if (!projectId) {
      alert("Please enter a Project ID before uploading files");
      return;
    }
    const formData = new FormData(document.getElementById("upload-form"));
    formData.append("projectId", projectId);

    try {
      const response = await fetch("/api/upload", {
        method: "POST",
        body: formData,
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Upload failed: ${errorText}`);
      }
      console.log("Files uploaded successfully for project:", projectId);
    } catch (error) {
      console.error("Upload error:", error);
      alert(`Upload failed: ${error.message}`);
    }
  }

  // Called if we want to highlight a specific trace node in the editor
  function highlightTraceNodeInEditor(node) {
    console.log("Highlighting trace node in editor:", node);
    setTraceNodeToHighlight(node);
  }

  // Hover callback from the Editor
  function handleHoverTraceId(traceId) {
    setHoveredTraceId(traceId);
  }

  // If user clicks a line in the Editor, fetch variable mappings from that line
  function handleLineClick(fileName, line) {
    console.log(`Line clicked => file: ${fileName}, line: ${line}`);
    if (!projectId) {
      console.error("No projectId set for variable mapping!");
      return;
    }
    fetch(`/api/varMapping?file=${encodeURIComponent(fileName)}&line=${line}&projectId=${projectId}`)
      .then((res) => {
        if (!res.ok) {
          throw new Error(`Variable mapping failed: ${res.status}`);
        }
        return res.json();
      })
      .then((variableNames) => {
        if (variableNames?.length > 0) {
          setSelectedVariable(variableNames[0]);
          console.log("Selected variable on that line:", variableNames[0]);
        } else {
          setSelectedVariable(null);
          console.log("No variable declared on that line.");
        }
      })
      .catch((err) => {
        console.error("Error fetching varMapping:", err);
        setSelectedVariable(null);
      });
  }

  // Fetch static methods from the server for the "Static Methods" view
  async function fetchStaticMethods() {
    if (!projectId) {
      alert("Please enter a Project ID first");
      return;
    }
    try {
      const resp = await fetch(`/api/static-methods?projectId=${projectId}`);
      if (!resp.ok) {
        throw new Error(`Failed to fetch static methods: ${resp.status}`);
      }
      const data = await resp.json();
      setStaticMethodsJson(data);
    } catch (error) {
      console.error("Error fetching static methods:", error);
      alert(`Error: ${error.message}`);
    }
  }

  // If user uploads a JSON file in DirectoryBar
  function handleJsonData(jsonData) {
    if (!jsonData) return;
    try {
      console.log("Initializing JSON Manager with uploaded JSON data...");
      setJsonManager(new JsonManager(jsonData));
    } catch (err) {
      console.error("JSON parse error:", err);
      alert("Error reading JSON data: " + err.message);
    }
  }

  // JBMC result fetch
  async function handleFetchJBMC() {
    if (!instrumentId) {
      alert("Please enter instrument ID first");
      return;
    }
    if (!projectId) {
      alert("Please enter a Project ID first");
      return;
    }
    try {
      const resp = await fetch(`/api/jbmc/result/${instrumentId}?projectId=${projectId}`);
      if (!resp.ok) {
        const errText = await resp.text();
        throw new Error(errText);
      }
      const data = await resp.json();
      setJbmcJson(data);
      setViewerMode("JBMC");
    } catch (error) {
      alert("Could not fetch JBMC JSON: " + error.message);
    }
  }

  // Toggle the middle container's collapsed state
  function toggleMiddleContainer() {
    setIsMiddleContainerCollapsed(!isMiddleContainerCollapsed);
  }

  // Launch a new project in a new tab
  function handleCreateNewProject() {
    window.open("/new-project", "_blank");
  }

  return (
    <div className="content">
      {/* LEFT COLUMN - DirectoryBar */}
      <DirectoryBar
        setDisplayedFile={setDisplayedFile}
        setDisplayedToActive={setDisplayedToActive}
        passOnUploadedFiles={passOnUploadedFiles}
        passOnJsonData={handleJsonData}   // If a user uploads some JSON
        projectId={projectId}            // For file upload and related actions
      />

      {/* MIDDLE COLUMN - collapsible sections */}
      <div className={`middle-container ${isMiddleContainerCollapsed ? "collapsed" : ""}`}>
        <button className="middle-container-toggle" onClick={toggleMiddleContainer}>
          {isMiddleContainerCollapsed ? "►" : "◄"}
        </button>

        {!isMiddleContainerCollapsed && (
          <>
            {/* JBMC Controls Section */}
            <CollapsibleSection title="JBMC Controls" defaultOpen={false}>
              <div>
                <input
                  placeholder="Instrument ID"
                  value={instrumentId}
                  onChange={(e) => setInstrumentId(e.target.value)}
                  className="input-field"
                />
                <button onClick={handleFetchJBMC}>Fetch JBMC Output</button>
                <div className="button-group">
                  <button onClick={() => setViewerMode("JSON")}>Show Normal JSON</button>
                  <button onClick={() => setViewerMode("JBMC")}>Show JBMC JSON</button>
                </div>
              </div>

              {viewerMode === "JBMC" && jbmcJson && (
                <JsonViewer
                  jsonData={jbmcJson}
                  onElementClick={(updated) => console.log("JBMC JSON clicked:", updated)}
                />
              )}

              {instrumentId && projectId && (
                <div style={{ marginTop: "10px" }}>
                  <MergedAssignmentsTable
                    traceId={instrumentId}
                    projectId={projectId}
                    selectedVariable={selectedVariable}
                  />
                </div>
              )}
            </CollapsibleSection>

            {/* Modular Actions Section */}
            <CollapsibleSection title="Modular Actions" defaultOpen={true}>
              {/* Note: ModularActions now manages its own Project ID input.
                  We no longer pass projectId, setProjectId, or uploadedFiles to it. */}
              <ModularActions
                projectName="MyProject"
                setJsonManager={setJsonManager}
                onVisualize={(vizJson) => {
                  console.log("Visualization JSON loaded:", vizJson);
                  setVisualizationJson(vizJson);
                }}
              />
            </CollapsibleSection>

            {/* Visualization Output Section */}
            <CollapsibleSection title="Visualization Output" defaultOpen={true}>
              <div style={{ display: "flex", gap: "10px", marginBottom: "10px" }}>
                <button
                  className={viewerMode === "JSON" ? "active-tab" : ""}
                  onClick={() => setViewerMode("JSON")}
                >
                  JSON
                </button>
                <button
                  className={viewerMode === "METHOD" ? "active-tab" : ""}
                  onClick={() => setViewerMode("METHOD")}
                >
                  Methods
                </button>
                <button
                  className={viewerMode === "TRACE" ? "active-tab" : ""}
                  onClick={() => setViewerMode("TRACE")}
                >
                  Trace
                </button>
                <button
                  className={viewerMode === "STATIC" ? "active-tab" : ""}
                  onClick={() => {
                    setViewerMode("STATIC");
                    fetchStaticMethods();
                  }}
                >
                  Static Methods
                </button>
              </div>

              {viewerMode === "JSON" && visualizationJson && (
                <JsonViewer
                  jsonData={visualizationJson}
                  onElementClick={(updated) => console.log("JSON viewer clicked:", updated)}
                />
              )}

              {viewerMode === "METHOD" && jsonManager && (
                <MethodTreeView
                  jsonManager={jsonManager}
                  onSelectMethod={(nodeIndex) => {
                    if (!jsonManager.nodes[nodeIndex]) return;
                    const methodNode = jsonManager.nodes[nodeIndex];
                    if (methodNode.link?.file) {
                      setActiveAndDisplayed(methodNode.link.file);
                    }
                    setActiveFunctionIndex(nodeIndex);
                    console.log("Selected method node:", nodeIndex, methodNode);
                    const initIters = jsonManager.initIterations(nodeIndex, []);
                    setActiveIterationIndices(initIters);
                  }}
                  className="method-view-section"
                />
              )}

              {viewerMode === "TRACE" && jsonManager && (
                <TraceTree
                  nodes={jsonManager.nodes}
                  onSelectTraceNode={(node) => {
                    if (node.link?.file) {
                      setActiveAndDisplayed(node.link.file);
                    }
                    highlightTraceNodeInEditor(node);
                  }}
                  hoveredTraceId={hoveredTraceId}
                />
              )}

              {viewerMode === "STATIC" && staticMethodsJson && (
                <JsonViewer
                  jsonData={staticMethodsJson}
                  onElementClick={(updated) => console.log("Static methods JSON clicked:", updated)}
                />
              )}
            </CollapsibleSection>
          </>
        )}
      </div>

      {/* RIGHT COLUMN - Editor */}
      <div className="right-container">
        <EditorManager
          displayedFile={displayedFile}
          setActiveAndDisplayed={setActiveAndDisplayed}
          isActiveDisplayed={isActiveDisplayed}
          jsonManager={jsonManager}
          activeFunctionIndex={activeFunctionIndex}
          setActiveFunctionIndex={setActiveFunctionIndex}
          traceNodeToHighlight={traceNodeToHighlight}
          setTraceNodeToHighlight={setTraceNodeToHighlight}
          onHoverTraceId={handleHoverTraceId}
          onLineClick={handleLineClick}
          activeIterationIndices={activeIterationIndices}
          setActiveIterationIndices={setActiveIterationIndices}
        />
      </div>
    </div>
  );
}

export default WebsiteContainer;