/**
 * Function to measure and report web-vital-values.
 * Important metrics for a good user experience.
 * @param {Function} onPerfEntry - A callback function that gets called to report measured performance.
 * */
const ReportWebVitals = onPerfEntry => {
    // Checks if callback function was provided and if it is a function.
    if (onPerfEntry && onPerfEntry instanceof Function) {
        // Loads in web-vitals module dynamically
        import('web-vitals').then(({getCLS, getFID, getFCP, getLCP, getTTFB}) => {
            // Calls the different web-vitals-functions and passes on the callback function.
            // Cumulative Layout Shift (CLS) measures stability of the layout.
            getCLS(onPerfEntry);
            // First Input Delay (FID) measures the time it takes the application to react after provided user input.
            getFID(onPerfEntry);
            // First Contentful Paint (FCP) measures the time before the first sign of content is loaded in.
            getFCP(onPerfEntry);
            // Largest Contentful Paint (LCP) measures loading time of biggest content.
            getLCP(onPerfEntry);
            // Time to First Byte (TTFB) measures the time until the first byte is received.
            getTTFB(onPerfEntry);
        });
    }
};

export default ReportWebVitals; // Export reportWebVitals function.
.json-viewer {
flex: 1;               /* fill parent vertical space if in a column layout */
  overflow-y: auto;      /* user can scroll inside when JSON is large */
  background-color: #222;
  color: #fff;
  min-height: 0;
}



.download-button {
  margin-top: 10px;
  padding: 10px 15px;
  background-color: #2196F3;
  color: #fff;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
.download-button:hover {
  background-color: #0b7dda;
}/* GLOBAL RESETS + SIZING */
html,
body,
#root {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  /* Ensure everything can expand fully */
  box-sizing: border-box;
  font-family: 'Roboto', sans-serif; /* A clean, modern font */
  background-color: #1F1F1F; /* Overall background color */
  color: #ECECEC; /* Light text color for dark background */
}

/* App container: top-level */
.App {
  display: flex;
  flex-direction: column; /* Navbar on top, main content below */
  width: 100%;
  height: 100vh;
}

/* NAVBAR */
.nav {
  display: flex;
  align-items: center;
  background-color: #222; /* Slightly lighter than background */
  height: 10vh; /* Takes 10% of screen height */
  padding: 0 20px; /* Horizontal padding */
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Logo + text */
.nav--icon {
  height: 48px;
  margin-right: 15px;
}
.nav--logo_text {
  margin-right: auto; /* pushes other items to the right */
  font-weight: 600;
  font-size: 1.2rem;
  color: #ffc7b1;
}
.nav--title {
  color: #ffc7b1;
  font-weight: 400;
  margin-right: 30px;
  font-size: 1rem;
}
.nav--help-button {
  background-color: #ffc7b1;
  color: #000;
  border: none;
  border-radius: 4px;
  padding: 8px 16px;
  cursor: pointer;
  font-weight: 500;
}
.nav--help-button:hover {
  background-color: #fda781;
}

/* CONTENT: all 3 columns fit into .content */
.content {
  flex: 1; /* fill remaining height */
  display: flex; /* side by side columns */
  flex-direction: row;
  height: 100%; /* since parent is 100vh minus nav */
  overflow: hidden; /* we’ll manage scroll within columns if needed */
}

/* LEFT CONTAINER */
.left-container {
  width: 18%; /* or 280px if you prefer a fixed px */
  min-width: 220px;
  max-width: 400px;
  background-color: #2A2A2A;
  border-right: 1px solid #444;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  overflow-y: auto; /* allows scrolling inside if too tall */
  transition: width 0.2s ease-in-out;
}

/* If user collapses left container */
.left-container.collapsed {
  width: 60px;
  min-width: 60px;
  overflow: hidden;
  background-color: #1F1F1F;
}
.left-container button {
  background-color: #333;
  color: #EEE;
  border: none;
  width: 100%;
  padding: 12px;
  font-weight: 500;
  cursor: pointer;
  text-align: left;
  transition: background-color 0.2s;
}
.left-container button:hover {
  background-color: #444;
}

/* The folder tree area below the “Close directory” button */
.folder-tree-container {
  flex: 1;
  margin: 0 10px;
  overflow-y: auto;
}

/* MIDDLE CONTAINER */
.middle-container {
  width: 25%;
  min-width: 250px;
  background-color: #2F2F2F;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  overflow: hidden; /* each child will scroll if needed */
}

/* top half: modular actions (like instrument/trace) */
.modular-actions-section {
  flex: 1; /* fill half vertically if also using the .json-viewer-section below */
  padding: 10px;
  overflow-y: auto;
  background-color: #3A3A3A;
}

/* .json-viewer-section for the bottom half */
.json-viewer-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: auto;
}

/* JSON VIEWER */
.json-viewer .react-json-view {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: #202020; /* a darker container for JSON */
  color:#;
  margin: 10px;
  border-radius: 4px;
  overflow: hidden;
}
.json-display {
  flex: 1;
  padding: 10px;
  overflow: auto;
}

/* Right container: the Monaco editor */
.right-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: #1E1E1E;
  color:#FFF-FFF;
  box-sizing: border-box;
  overflow: hidden;
}

/* Editor container for Monaco */
.editor-container {
  flex: 1;
  width: 100%;
  min-height: 0;
  position: relative;
  overflow: hidden;
  box-shadow: inset 0 0 10px #000;
}

/* DECORATIONS FOR THE EDITOR */
.inactive {
  background-color: rgba(178, 34, 34, 0.6); /* firebrick red */
}
.active {
  background-color: rgba(34, 139, 34, 0.6); /* forest green */
}
.link {
  background-color: rgba(30, 144, 255, 0.6); /* dodgerblue */
}
.loop {
  background-color: rgba(128, 0, 128, 0.6); /* purple */
}
.start {
  content: url('../Images/start.png');
}
.line {
  content: url('../Images/line.png');
}
.end {
  content: url('../Images/end.png');
}
.one-line {
  content: url('../Images/oneLine.png');
}

/* Additional popup styling (if used) */
.popup {
  position: absolute;
  background-color: #FFF;
  color: #000;
  border: 1px solid #CCC;
  padding: 10px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.5);
  z-index: 1000;
}

/* MISC decorations */
.my-loop-decoration {
  background-color: pink;
  opacity: 0.7;
}
.my-glyph-margin-class {
  width: 4px;
  background-color: pink;
  margin-left: 4px;
}
.for-loop-decoration,
.if-statement-decoration,
.else-statement-decoration,
.while-loop-decoration {
  position: absolute;
  margin-left: -50px; /* adjust as needed */
  border-left: 4px solid #3498db;
}
.begin-line-highlight {
  background-color: rgba(245, 10, 10, 0.3);
}
.my-line-numbers {
  color: #f33 !important;
}

/* MONACO TOKEN COLORS OVERRIDES */
.monaco-editor.token.keyword {
  color: #C792EA;
  font-weight: bold;
}
.monaco-editor.token.function {
  color: #C3E88D;
}
.monaco-editor.token.type {
  color: #FFCB6B;
}
.monaco-editor.token.identifier {
  color: #D6DEEB;
}
.monaco-editor.token.string {
  color: #C3E88D;
}
.monaco-editor.token.number {
  color: #F78C6C;
}
.monaco-editor.token.operator {
  color: #89DDFF;
}
.monaco-editor.token.annotation {
  color: #82AAFF;
}
.monaco-editor.token.regex {
  color: #ECC48D;
}
.monaco-editor.token.delimiter {
  color: #89DDFF;
}
.monaco-editor.token.invalid {
  background-color: #FF5370;
  color: #FFF;
}
.monaco-editor .monaco-editor-hover {
  z-index: 1000;
  position: fixed;
  visibility: visible;
}
.monaco-editor-hover .monaco-editor-hover-content {
  background-color: #FFF;
  color: #000;
  border: 1px solid #444;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  padding: 8px;
}

/* Modal styling (Help, etc.) */
.modal-container {
  max-width: 600px;
  margin: 80px auto;
  padding: 20px;
  background-color: #2F2F2F;
  color: #EEE;
  border-radius: 8px;
  border: 1px solid #555;
}
.modal-close-button {
  background-color: #ffc7b1;
  color: #000;
  border: none;
  padding: 8px 16px;
  font-size: 16px;
  cursor: pointer;
  border-radius: 4px;
}
.modal-content {
  margin-top: 20px;
}
.modal {
  /* If you need to style the overall modal container from ReactModal, do it here */
}

/* Buttons used in the top left area (like "Upload") */
.upload-button-container,
.reset-button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 1rem 0;
}
.picker {
  margin-right: 0;
  margin-bottom: 1rem;
  color: #FFF;
  background-color: #444;
  border: none;
  padding: 8px;
  border-radius: 4px;
}
.picker:hover {
  background-color: #555;
}
.download-button {
  margin-top: 10px;
  padding: 8px 16px;
  background-color: #3498db;
  color: #FFF;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
.download-button:hover {
  background-color: #1D7CC0;
}

/*
  =============== NEW STYLES FOR METHODVIEW + TRACETREE ==============
*/

.method-view-section {
  margin: 10px;
  padding: 10px;
  background-color: #444;
  border: 1px solid #666;
  border-radius: 4px;
  color: #fff;
}

.method-view-section h3 {
  margin: 0 0 8px 0;
  font-size: 1rem;
  color: #eee;
}

.method-view-section select.method-view-dropdown {
  width: 100%;
  padding: 6px;
  background-color: #555;
  color: #fff;
  border: 1px solid #666;
  border-radius: 4px;
  font-size: 0.9rem;
}

/* ================================ */
/*       TRACE TREE STYLES          */
/* ================================ */
.trace-tree-container {
  margin: 10px;
  padding: 10px;
  border: 1px solid #666;
  background-color: #444;
  border-radius: 4px;
  color: #fff;
  max-height: 200px; /* or any you want */
  overflow-y: auto;
}

.trace-tree-container ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

.trace-tree-container li {
  margin: 4px 0;
  cursor: pointer;
  transition: background-color 0.2s;
}

.trace-tree-container li:hover {
  background-color: #555;
}

.trace-tree-clickable {
  /* If you want a specific style for clickable nodes */
}

.trace-tree-clickable.highlight {
  background-color: #666;
  /* Or your highlight color */
}
/* Add this in your CSS file to style highlighted methods */

.highlighted-method {
  background-color: rgba(34, 139, 34, 0.3); /* Light green background for active methods */
  border-radius: 3px;
}
// Imports the React module.
import React from 'react';

// Imports the ReactDom module from 'react-dom/client'(refers to newest react version).
import {createRoot} from 'react-dom/client';

// Imports CSS-File for styling.
import './Css/App.css';

// Imports the App-component from App.js.
import App from './App.js';

// Imports the function reportWebVitals for measuring the performance of the web application.
import reportWebVitals from './ReportWebVitals.js';

// Determines the DOM-Element with the ID 'root' that is used as an anchor point for the React application.
const rootElement = document.getElementById('root');

// Checks if the 'rootElement' is present to prevent errors.
if (rootElement) {
    // Creates the Root-Element through 'createRoot' from 'react-dom/client'.
    const root = createRoot(rootElement);

    // Uses 'root.render()', to render the app-component inside the <React.StrictMode>-wrapper.
    // <React.StrictMode> is used to activate additional tests and warnings for the app.
    root.render(
        <React.StrictMode>
            <App/>
        </React.StrictMode>
    );
}

// reportWebVitals is called to capture performance data and report it.
// This can be used for analysing and optimizing the performance.
// More information about this process can be found here: https://bit.ly/CRA-vitals
reportWebVitals(console.log);  //'console.log' gets passed on as an example-callback-function.// MethodTreeView.js

import React, { useState, useMemo } from "react";
import PropTypes from "prop-types";

/**
 * Build a tree of "Function" nodes from jsonManager.nodes:
 * - Each node gains a `children` array, containing child function nodes.
 * - Return an array of "root" function nodes (those whose parent is not a function).
 */
function buildFunctionTree(jsonManager) {
  if (!jsonManager || !jsonManager.nodes) {
    return [];
  }

  // 1) Create a quick map from node index -> node
  const indexToNode = {};
  jsonManager.nodes.forEach((node, idx) => {
    indexToNode[idx] = node;
  });

  // 2) Prepare each node for children
  jsonManager.nodes.forEach((node) => {
    // We'll add a `children` array
    node.children = [];
  });

  // 3) For each function node, push any child function nodes
  jsonManager.nodes.forEach((node, idx) => {
    if (node.nodeType === "Function") {
      node.childrenIndices.forEach((childIndex) => {
        const childNode = indexToNode[childIndex];
        if (childNode && childNode.nodeType === "Function") {
          // childNode is also a function, so nest it
          node.children.push(childNode);
        }
      });
    }
  });

  // 4) Identify root function nodes:
  //    (1) parentIndex is null/negative, or
  //    (2) parent's nodeType != "Function"
  const rootFunctions = [];
  jsonManager.nodes.forEach((node, idx) => {
    if (node.nodeType === "Function") {
      const parentIndex = node.parentIndex;
      if (
        parentIndex === null ||
        parentIndex < 0 ||
        indexToNode[parentIndex].nodeType !== "Function"
      ) {
        rootFunctions.push(node);
      }
    }
  });

  return rootFunctions;
}

/**
 * Recursive component that displays a single function node.
 * - Expands/collapses if it has child function nodes.
 * - Renders a "Select" button to pick this node.
 */
function FunctionTreeItem({ node, onSelect }) {
  // Local expanded/collapsed state
  const [expanded, setExpanded] = useState(false);

  // If node has child function nodes
  const hasChildren = node.children && node.children.length > 0;

  const toggleExpand = (e) => {
    e.stopPropagation(); // so we don't conflict with the button's click
    setExpanded((prev) => !prev);
  };

  const handleSelect = (e) => {
    e.stopPropagation();
    onSelect(node);
  };

  return (
    <li style={{ margin: "4px 0" }}>
      <div
        style={{
          display: "flex",
          alignItems: "center",
          cursor: hasChildren ? "pointer" : "default",
        }}
        onClick={toggleExpand}
      >
        {hasChildren && (
          <span style={{ marginRight: "6px", fontSize: "0.8rem" }}>
            {expanded ? "▼" : "►"}
          </span>
        )}
        {!hasChildren && <span style={{ marginRight: "14px" }} />}
        {/* just spacing if no children */}

        <button
          style={{ marginRight: "8px" }}
          onClick={handleSelect}
        >
          Select
        </button>
        <span>{node.nodeMethodName || "UnnamedMethod"}</span>
      </div>
      {hasChildren && expanded && (
        <ul style={{ listStyle: "none", marginLeft: "20px", paddingLeft: 0 }}>
          {node.children.map((child, idx) => (
            <FunctionTreeItem key={idx} node={child} onSelect={onSelect} />
          ))}
        </ul>
      )}
    </li>
  );
}

FunctionTreeItem.propTypes = {
  node: PropTypes.object.isRequired,   // a single function node
  onSelect: PropTypes.func.isRequired, // callback when user clicks "Select"
};

/**
 * Main component that:
 *  - Builds the function tree from jsonManager
 *  - Renders root-level function nodes, each of which
 *    recursively renders children
 *  - Calls onSelectMethod when user selects a node
 */
export default function MethodTreeView({ jsonManager, onSelectMethod, className }) {
  // Build the tree once
  const rootFunctions = useMemo(() => buildFunctionTree(jsonManager), [jsonManager]);

  if (!jsonManager || !jsonManager.nodes) {
    return <div className={className}>No jsonManager or nodes available.</div>;
  }

  if (rootFunctions.length === 0) {
    return <div className={className}>No function nodes found.</div>;
  }

  // On "Select" we find the node's index in jsonManager.nodes, pass to onSelectMethod
  const handleSelectNode = (node) => {
    const idx = jsonManager.nodes.indexOf(node);
    onSelectMethod(idx);
  };

  return (
    <div className={className}>
      <h3>Method Hierarchy (Tree)</h3>
      <ul style={{ listStyle: "none", paddingLeft: 0 }}>
        {rootFunctions.map((rootNode, i) => (
          <FunctionTreeItem
            key={i}
            node={rootNode}
            onSelect={handleSelectNode}
          />
        ))}
      </ul>
    </div>
  );
}

MethodTreeView.propTypes = {
  jsonManager: PropTypes.object,
  onSelectMethod: PropTypes.func.isRequired,
  className: PropTypes.string,
};import React, {useState} from 'react';
import PropTypes from "prop-types";

/**
 * Defines a modal component that displays readme or help information to the user.
 * This functional component renders a modal dialog containing a title and a message
 * indicating that help will not be provided from external sources. A close button is
 * also provided, allowing the user to dismiss the modal. This component demonstrates
 * the use of props in React for passing the closeModal function, enabling the modal
 * to be closed from within.
 * @param {Function} props.closeModal - Function to close the modal.
 */
export default function ReadmeModal({closeModal}) {
    const content = [
        <div key={1}><b> Welcome to ProRunVis: </b>
            <p> ProRunVis is a code analysis tool that is supposed to help you understand the control flow of your
                code through visualization. </p></div>,
        <div key={2}><b> Upload: </b>
            <p> Use the <b>choose-files-button</b> to upload the root folder of a Java project of your choosing. </p>
            <p> The chosen project has to be in a separate folder with only the project-packages in it. It
                furthermore should not use any external libraries the program is currently not able to deal with
                those.</p>
            <p> The code of your project then gets shown on the <b>right side</b>. </p></div>,
        <div key={3}><b> Visualization: </b>
            <p> Only one function call is visualized at the same time. </p>
            <p style={{backgroundColor: "green"}}> <b>Green</b> background indicates that a statement has been
                executed. </p>
            <p style={{backgroundColor: "blue"}}> <b>Blue</b> background indicates a jump at that position to another part
                of the
                code. Click it to go there and change the function call currently visualized. </p>
            <p style={{backgroundColor: "purple"}}> <b>Purple</b> background indicates a loop that has been executed, click
                it to
                select the iteration that you
                want displayed. </p>
            
            <p> The <b>line</b> on the left side of your code is shown to indicate what path the program took.
                It is decorated with <b>elements</b> that help you to identify specific code structures such as loops or
                    function calls.</p></div>,
        <div key={4}><b> Navigation: </b>
            <p> You can use the <b>directory bar</b> on the left side to open all the Java files in your project. </p>
            <p> If you want to jump back to the file with the function currently visualized you can use the <b>Jump-to-active-function-button</b>, it will open the file for you and display the function.</p> </div>];

    const [currentIndex, setCurrentIndex] = useState(0);

    const handleBack = () => {
        setCurrentIndex((prevIndex) => Math.max(prevIndex - 1, 0));
    };

    const handleNext = () => {
        setCurrentIndex((prevIndex) => Math.min(prevIndex + 1, content.length - 1));
    };

    return (
        <div className="modal-container">
            <button className="modal-close-button" onClick={closeModal}>
                Close
            </button>
            <div className="modal-content">
                <h2><u>Tutorial</u></h2>
            </div>
            <div className="modal-buttons">
                <button onClick={handleBack} disabled={currentIndex === 0}>
                    Back
                </button>
                <button onClick={handleNext} disabled={currentIndex === content.length - 1}>
                    Next
                </button>
                <b> {currentIndex + 1} / {content.length} </b>
            </div>
            <div><p></p>{content[currentIndex]}</div>
        </div>
    );
}
    ReadmeModal.propTypes = {
        closeModal: PropTypes.instanceOf(Function)
    };import React from "react";
import HelpButton from "./HelpButton";
import logoImage from "../Images/CDProRunVis.png";
import "../Css/App.css";

/**
 * Represents the navigation bar at the top of the application. It includes a logo,
 * application title "Visualize your flow", and a HelpButton component that opens
 * a modal with additional information or instructions for the user. The Navbar
 * is styled with CSS for visual appeal and user interaction.
 */
export default function Navbar() {
    return (
        <nav className="nav">
            <img
                src={logoImage}
                className="nav--icon"
                alt="A debugger logo"
            />
            <h3 className="nav--logo_text">Visualize your flow</h3>
            <h4 className="nav--title"></h4>
            <HelpButton/>
        </nav>
    );
}import React from 'react';
import ReactJson from 'react-json-view';
import '../Css/App.css';
import PropTypes from 'prop-types';

function JsonViewer({ jsonData, onElementClick }) {
    const handleJsonClick = (click) => {
        if (onElementClick) {
            if (click.updated_src) {
                onElementClick(click.updated_src);
            } else if (click.namespace) {
                onElementClick(click.namespace);
            }
        }
    };

    const handleDownload = () => {
        const fileName = 'data.json';
        const jsonStr = JSON.stringify(jsonData, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(url);
    };

    return (
        <div className="json-viewer">
            <h2>JSON-Datei anzeigen</h2>
            <div className="json-display">
                <ReactJson
                    src={jsonData}
                    theme="monokai"
                    collapsed={2}
                    enableClipboard={true}
                    onEdit={handleJsonClick}
                    onDelete={handleJsonClick}
                    onAdd={handleJsonClick}
                    onSelect={handleJsonClick}
                />
            </div>
            <button onClick={handleDownload} className="download-button">
                JSON-Datei herunterladen
            </button>
        </div>
    );
}

JsonViewer.propTypes = {
    jsonData: PropTypes.object.isRequired,
    onElementClick: PropTypes.func
};

export default JsonViewer;// StaticMethodsView.js
import React, { useEffect, useState } from 'react';

const StaticMethodsView = () => {
  const [methods, setMethods] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  // Fetch the static methods from the endpoint when the component mounts
  useEffect(() => {
    setLoading(true);
    fetch('/api/static-methods')
      .then((response) => {
        if (!response.ok) {
          throw new Error('Network response was not ok.');
        }
        return response.json();
      })
      .then((data) => {
        setMethods(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err.message);
        setLoading(false);
      });
  }, []);

  return (
    <div style={{ padding: '1rem', backgroundColor: '#222', color: '#fff' }}>
      <h2>Static Methods (Extracted from Source Code)</h2>
      {loading && <div>Loading static methods...</div>}
      {error && <div style={{ color: 'red' }}>Error: {error}</div>}
      {methods && (
        <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
          {JSON.stringify(methods, null, 2)}
        </pre>
      )}
    </div>
  );
};

export default StaticMethodsView;import React from 'react';
import PropTypes from 'prop-types';

/**
 * Renders a tree/list of all TraceNodes from your jsonManager.
 *
 * - nodes: an array of all nodes (jsonManager.nodes).
 * - onSelectTraceNode: callback, called when user clicks a node in the tree,
 *                      typically so you can highlight in the code editor.
 * - hoveredTraceId: if you want to highlight an item when user hovers code,
 *                   pass the traceId here (optional).
 */
export default function TraceTree({ nodes, onSelectTraceNode, hoveredTraceId }) {
  if (!nodes || nodes.length === 0) {
    return <div>No trace data.</div>;
  }

  return (
    <div style={{ overflowY: 'auto', maxHeight: '200px', border: '1px solid #666' }}>
      <h3>Trace Tree</h3>
      <ul style={{ paddingLeft: '1rem' }}>
        {nodes.map((node, idx) => (
          <li
            key={node.traceId || idx}
            style={{
              backgroundColor:
                hoveredTraceId && hoveredTraceId === node.traceId
                  ? 'yellow'
                  : 'transparent',
            }}
            onClick={() => onSelectTraceNode(node)}
          >
            {/* Show ID and maybe method name */}
            <b>{node.traceId}</b> {/* Use node.traceId directly */}
            ({node.nodeType}
            {node.nodeMethodName ? `: ${node.nodeMethodName}` : ''})
          </li>
        ))}
      </ul>
    </div>
  );
}

TraceTree.propTypes = {
  nodes: PropTypes.array.isRequired,
  onSelectTraceNode: PropTypes.func.isRequired,
  hoveredTraceId: PropTypes.string,
};import React, {useEffect, useState} from 'react';
import FolderTree from 'react-folder-tree';
import 'react-folder-tree/dist/style.css';
import "../Css/App.css"
import PropTypes from "prop-types";

/**
 * Represents the left component of the application, which is primarily responsible for
 * displaying a folder tree of Java files. This component allows users to select a directory,
 * filters out Java files, and displays these files in a structured folder tree view.
 * Users can collapse or expand the left container to show or hide the folder tree.
 * @param setDisplayedFile Function to change the active file to the one given.
 * @param setDisplayedToActive Function to reset the view to the currently active Node.
 * @param passOnUploadedFiles Pass the uploaded files to the parent component.
 * @param passOnJsonData Pass the uploaded JSON data to the parent component.
 * @returns {Element} The left component containing the upload button and dir bar.
 * @constructor
 */
function DirectoryBar({setDisplayedFile, setDisplayedToActive, passOnUploadedFiles, passOnJsonData}) {
    // State for the list of files uploaded by the user.
    const [uploadedFiles, setUploadedFiles] = useState([]);
    // State for the structured data used by FolderTree to display the directory and files.
    const [folderTreeData, setFolderTreeData] = useState(null);
    // State to manage the collapsed or expanded state of the left container.
    const [isLeftContainerCollapsed, setIsLeftContainerCollapsed] = useState(false);

    // Zustand für das hochgeladene JSON-File
    const [uploadedJsonFile, setUploadedJsonFile] = useState(null);

    /**
     * Handles the upload of files, filters for Java files, and constructs the folder tree data.
     * @param {Event} event - The file input change event.
     */
    const handleFileUpload = (event) => {
        const filteredFiles = Array.from(event.target.files).filter(file =>
            file.webkitRelativePath.endsWith('.java')
        );
        setUploadedFiles(filteredFiles);
        if (filteredFiles.length > 0) {
            const directoryName = filteredFiles[0].webkitRelativePath.split('/')[0];
            const treeData = buildFolderTree(filteredFiles, directoryName);
            setFolderTreeData(treeData);
        }
    };

    /**
     * Builds the folder tree structure from the list of selected files.
     * @param {Array} fileList - The list of filtered files.
     * @param {string} directoryName - The name of the root directory.
     * @return {Object} The root object of the folder tree structure.
     */
    const buildFolderTree = (fileList, directoryName) => {
        const root = {name: directoryName, isOpen: true, children: []};
        let i = 0;
        fileList.forEach(file => {
            const splitPath = file.webkitRelativePath.split('/');
            let currentLevel = root;

            splitPath.forEach((part, index) => {
                if (index > 0) {
                    const nodeName = part.replace('.java', ''); // Remove .java extension
                    let existingNode = currentLevel.children.find(child => child.name === nodeName);

                    const isDirectory = index < splitPath.length - 1; // Determine if it's a directory
                    if (!isDirectory && !existingNode) {
                        existingNode = {
                            name: nodeName,
                            realPath: file.webkitRelativePath,
                            index: i,
                            children: isDirectory ? [] : undefined // Add children only for directories
                        };
                        i++;
                        currentLevel.children.push(existingNode);
                    } else if (!existingNode) {
                        existingNode = {
                            name: nodeName,
                            children: isDirectory ? [] : undefined // Add children only for directories
                        };
                        currentLevel.children.push(existingNode);
                    }
                    currentLevel = existingNode; // Descend into the directory
                }
            });
        });
        return root;
    };

    /**
     * Toggles the collapsed state of the left container.
     */
    const toggleLeftContainer = () => {
        setIsLeftContainerCollapsed(!isLeftContainerCollapsed);
    };

    /**
     * Custom event handler for node name click.
     */
    const onNameClick = ({nodeData}) => {
        const {
            // internal data
            path, name, checked, isOpen, realPath, index
        } = nodeData;
        if (realPath != null) {
            setDisplayedFile(uploadedFiles[index]);
        }
    };

    /**
     * Event-Handler für den JSON-File-Upload.
     */
    const handleJsonFileUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
            setUploadedJsonFile(file);
            uploadJsonFileToBackend(file);
        }
    };

    /**
     * Funktion zum Hochladen der JSON-Datei an das Backend.
     * @param {File} file - Die hochgeladene JSON-Datei.
     */
    const uploadJsonFileToBackend = async (file) => {
        const formData = new FormData();
        formData.append('jsonFile', file);

        try {
            const response = await fetch('/api/upload-json', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const jsonData = await response.json();
                // Übergibt die JSON-Daten an die übergeordnete Komponente
                passOnJsonData(jsonData);
                // Zeigt eine Erfolgsmeldung an
                alert('JSON-Datei erfolgreich hochgeladen!');
            } else {
                // Fehlerbehandlung
                alert('Fehler beim Hochladen der JSON-Datei.');
            }
        } catch (error) {
            console.error('Fehler beim Hochladen der JSON-Datei:', error);
            alert('Ein unerwarteter Fehler ist aufgetreten.');
        }
    };

    /**
     * Pass uploaded files to parent component, every time they change
     */
    useEffect(() => {
        if (uploadedFiles.length > 0) {
            passOnUploadedFiles(uploadedFiles);
        }
    }, [uploadedFiles]);

    return (
        <main className={`left-container ${isLeftContainerCollapsed ? 'collapsed' : ''}`}
              style={{width: isLeftContainerCollapsed ? '50px' : '280px'}}>
            <button onClick={toggleLeftContainer}>{isLeftContainerCollapsed ? 'Open' : 'Close directory'}</button>
            {isLeftContainerCollapsed ? null : (
                <div>
                    <button onClick={setDisplayedToActive}>{'Jump to active function'} </button>
                    <div className="upload-button-container">
                        <form id="upload-form" className="text-box" encType="multipart/form-data">
                            <input
                                type="file"
                                name="file"
                                multiple
                                webkitdirectory=""
                                onChange={handleFileUpload}
                                className="picker"
                            />
                        </form>
                    </div>

                    {/* Neuer JSON-Upload-Bereich */}
                    <div className="upload-json-container" style={{ marginTop: '20px' }}>
                        <form id="json-upload-form" encType="multipart/form-data">
                            <input
                                type="file"
                                name="jsonFile"
                                accept=".json"
                                onChange={handleJsonFileUpload}
                                className="picker"
                            />
                        </form>
                    </div>

                    {folderTreeData && (
                        <div className="folder-tree-container">
                            <FolderTree
                                data={folderTreeData}
                                onNameClick={onNameClick}
                                showCheckbox={false}
                                readOnly={true}
                                indentPixels={15}
                            />
                        </div>
                    )}
                </div>
            )}
        </main>
    );
}

DirectoryBar.propTypes = {
    setDisplayedFile: PropTypes.instanceOf(Function).isRequired,
    setDisplayedToActive: PropTypes.instanceOf(Function).isRequired,
    passOnUploadedFiles: PropTypes.instanceOf(Function).isRequired,
    passOnJsonData: PropTypes.instanceOf(Function).isRequired, // Neue Prop
};

export default DirectoryBar;
import React, {useState} from "react";
import Modal from "react-modal";
import ReadmeModal from "./ReadmeModal";
import "../Css/App.css"

// Sets the app element for accessibility reasons, which helps screen readers.
Modal.setAppElement("#root");

/**
 * Defines a HelpButton component using ReactModal for displaying help information.
 * This component manages the state of the modal (open/close) and renders a button
 * that, when clicked, opens a modal containing the ReadmeModal component. This modal
 * provides help or documentation to the user. The component demonstrates the use of
 * React's useState hook for state management and the integration of third-party modal
 * functionality for enhanced UI interactions.
 */
export default function HelpButton() {
    // State to track if the modal is open or closed.
    const [modalIsOpen, setModalIsOpen] = useState(false);

    /**
     * Opens the modal by setting the modalIsOpen state to true.
     */
    const openModal = () => {
        setModalIsOpen(true);
    };

    /**
     * Closes the modal by setting the modalIsOpen state to false.
     */
    const closeModal = () => {
        setModalIsOpen(false);
    };

    return (
        <>
            <button className="nav--help-button" onClick={openModal}>
                Help
            </button>
            <Modal className="modal"
                isOpen={modalIsOpen}
                onRequestClose={closeModal}
                contentLabel="Readme Modal"
            >
                <ReadmeModal closeModal={closeModal/* Renders the content of the modal.*/}/>
            </Modal>
        </>
    );
}
import React, { useState } from 'react';
import PropTypes from 'prop-types';

function ModularActions({ setJsonManager, projectName, onVisualize }) {
  // State variables
  const [instrumentId, setInstrumentId] = useState("");
  const [traceId, setTraceId] = useState("");
  const [processedTracePath, setProcessedTracePath] = useState("");
  const [visualizationJson, setVisualizationJson] = useState(null);
  const [jbmcMethodSig, setJbmcMethodSig] = useState("SnowWhite.indexMax:([I)I");
  const [jbmcUnwind, setJbmcUnwind] = useState(5);
  const [jbmcArrayLength, setJbmcArrayLength] = useState(5);

  // 1) INSTRUMENT
  const handleInstrument = async () => {
    try {
      const response = await fetch(
        `/api/instrument?projectName=${encodeURIComponent(projectName)}&inputDir=resources/in`,
        { method: "POST" }
      );
      const idText = await response.text(); // returns a string ID/path
      alert("Instrument ID (local): " + idText);
      setInstrumentId(idText.trim());
    } catch (error) {
      console.error("Error instrumenting project:", error);
      alert("Instrumentation failed.");
    }
  };

  // 2) TRACE
  const handleTrace = async () => {
    if (!instrumentId) {
      alert("No instrumentId set!");
      return;
    }
    try {
      const response = await fetch(`/api/trace?instrumentId=${instrumentId}`, {
        method: "POST"
      });
      const idText = await response.text(); // e.g., a path to Trace.tr
      alert("Trace ID (local): " + idText);
      setTraceId(idText.trim());
    } catch (error) {
      console.error("Error running trace:", error);
      alert("Trace run failed.");
    }
  };

  // 3) PROCESS
  const handleProcess = async () => {
    if (!traceId) {
      alert("No traceId set!");
      return;
    }
    try {
      const response = await fetch(`/api/process?traceId=${traceId}`, {
        method: "POST"
      });
      const resultText = await response.text();
      alert("Processed trace stored locally under ID: " + resultText);
      setProcessedTracePath(resultText.trim());
    } catch (error) {
      console.error("Error processing trace:", error);
      alert("Processing failed.");
    }
  };

  // 4) VISUALIZE
  const handleVisualize = async () => {
    if (!processedTracePath) {
      alert("No processedTrace path (local ID) set!");
      return;
    }
    try {
      const localId = processedTracePath;
      const resp = await fetch(`/api/visualize/${localId}`);
      if (!resp.ok) {
        throw new Error("Failed to fetch processed trace");
      }
      const data = await resp.json();
      console.log("Parsed JSON data:", data);

      // Save to local state
      setVisualizationJson(data);

      // Execute parent callback if provided
      if (onVisualize) {
        onVisualize(data);
      }

      // Dynamically import the JsonManager and load the data
      const { default: JsonManager } = await import("./Editor/JsonManager.js");
      setJsonManager(new JsonManager(data));
    } catch (error) {
      console.error("Error visualizing trace JSON:", error);
      alert("Visualization failed.");
    }
  };

  // JBMC: Run JBMC with the provided parameters
  const handleRunJBMC = async () => {
    if (!instrumentId) {
      alert("You must have an instrumentId set (the same as used for trace).");
      return;
    }
    try {
      const params = new URLSearchParams({
        instrumentId,
        methodSignature: jbmcMethodSig,
        unwind: jbmcUnwind,
        maxArray: jbmcArrayLength
      });
      const resp = await fetch(`/api/jbmc/run?${params.toString()}`, { method: 'POST' });
      if (!resp.ok) {
        const errText = await resp.text();
        throw new Error(`JBMC run failed: ${errText}`);
      }
      alert("JBMC run succeeded! Check /api/jbmc/result/<instrumentId> or the UI below.");
    } catch (error) {
      console.error("Error running JBMC:", error);
      alert("JBMC error: " + error.message);
    }
  };

  // Allows user to download the visualization JSON
  const handleDownloadJson = () => {
    if (!visualizationJson) return;
    const jsonStr = JSON.stringify(visualizationJson, null, 2);
    const blob = new Blob([jsonStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "visualization.json";
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div style={{ padding: "10px", backgroundColor: "#333", color: "white" }}>
      <h3>Modular Actions (Local Storage Flow)</h3>

      {/* Instrument Section */}
      <div style={{ marginBottom: "1rem" }}>
        <button onClick={handleInstrument}>Instrument</button>
        <br />
        <label>
          Instrument ID:{" "}
          <input
            type="text"
            value={instrumentId}
            onChange={(e) => setInstrumentId(e.target.value)}
          />
        </label>
      </div>

      {/* JBMC Section */}
      <div style={{ marginBottom: "1rem" }}>
        <h4>JBMC</h4>
        <label>
          Instrument ID:{" "}
          <input
            type="text"
            value={instrumentId}
            onChange={(e) => setInstrumentId(e.target.value)}
            placeholder="e.g. 1234-uuid from instrumentation"
          />
        </label>
        <br />
        <label>
          Method Signature:{" "}
          <input
            type="text"
            value={jbmcMethodSig}
            onChange={(e) => setJbmcMethodSig(e.target.value)}
          />
        </label>
        <br />
        <label>
          Unwind:{" "}
          <input
            type="number"
            value={jbmcUnwind}
            onChange={(e) => setJbmcUnwind(Number(e.target.value))}
          />
        </label>
        <br />
        <label>
          Max Array Length:{" "}
          <input
            type="number"
            value={jbmcArrayLength}
            onChange={(e) => setJbmcArrayLength(Number(e.target.value))}
          />
        </label>
        <br />
        <button onClick={handleRunJBMC}>Run JBMC</button>
      </div>

      {/* Trace Section */}
      <div style={{ marginBottom: "1rem" }}>
        <button onClick={handleTrace}>Trace</button>
        <br />
        <label>
          Trace ID (local path):{" "}
          <input
            type="text"
            value={traceId}
            onChange={(e) => setTraceId(e.target.value)}
          />
        </label>
      </div>

      {/* Process Section */}
      <div style={{ marginBottom: "1rem" }}>
        <button onClick={handleProcess}>Process</button>
        <br />
        <label>
          Processed Trace Path (local ID):{" "}
          <input
            type="text"
            value={processedTracePath}
            onChange={(e) => setProcessedTracePath(e.target.value)}
          />
        </label>
      </div>

      {/* Visualize Section */}
      <div style={{ marginBottom: "1rem" }}>
        <button onClick={handleVisualize}>Visualize</button>
      </div>

      {/* Download Visualization JSON */}
      {visualizationJson && (
        <div style={{ marginBottom: "1rem" }}>
          <button onClick={handleDownloadJson}>Download Visualization JSON</button>
        </div>
      )}
    </div>
  );
}

ModularActions.propTypes = {
  projectName: PropTypes.string.isRequired,
  setJsonManager: PropTypes.func.isRequired,
  onVisualize: PropTypes.func,
  uploadedFiles: PropTypes.array
};

export default ModularActions;
import React, {useEffect, useRef} from 'react';
import Navbar from "./WebsiteElements/Navbar";
import WebsiteContainer from "./WebsiteContainer";

/**
 * Observes Left/RightContainer for correct resizing. Prohibits sending too many requests to DOM, which causes a Runtime Error.
 */
const debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

/**
 * Represents the main application component in the React application.
 * This component initializes a content area with dynamic resize handling.
 * It utilizes a ResizeObserver to monitor changes in the size of the container element
 * and debounces the resize events to limit the frequency of handling callbacks.
 *
 * <p>Upon component mount, it sets up an observer on the content container to listen for resize events.
 * When the container's size changes, it logs a message indicating that the container size has changed.
 * This is intended to demonstrate how to handle dynamic content resizing in React components.
 *
 * <p>The cleanup function returned by useEffect ensures that the observer is disconnected
 * when the component unmounts, preventing potential memory leaks.
 *
 * @return A React component that displays the application layout, including a navbar
 *         and a content area divided into left and right components. The content area
 *         is monitored for size changes, demonstrating dynamic resize handling.
 */
function App() {
    const contentRef = useRef(null);

    useEffect(() => {

        const handleResize = debounce(() => {

        }, 100);

        const observer = new ResizeObserver(handleResize);
        if (contentRef.current) {
            observer.observe(contentRef.current);
        }

        return () => observer.disconnect(); // Cleanup-Function and disconnects
    }, []);

   return (
       <div className="App">
         <Navbar />
           <WebsiteContainer />

       </div>
     );
}

export default App;
import React, { useEffect, useRef, useState } from "react";
import PropTypes from "prop-types";
import EditorInitializer from "./EditorInitializer";
import JsonManager from "./JsonManager";
import * as monaco from "monaco-editor/esm/vs/editor/editor.api";
import loopImage from "../Images/loop.png";
import linkImage from "../Images/link.png";
import outlinkImage from "../Images/outlink.png";
import "../Css/App.css";
import "../Css/App.css";

function EditorManager({
 displayedFile,
   setActiveAndDisplayed,
   isActiveDisplayed,
   jsonManager,
   activeFunctionIndex,
   setActiveFunctionIndex,
   traceNodeToHighlight,
   setTraceNodeToHighlight,
   onHoverTraceId,
  activeIterationIndices,
  setActiveIterationIndices,
}) {
  // State for the indices of the loop iterations currently active.


  // State for the indices of the Nodes (other functions and throws)
  // of the active function that can be used to jump to another node.
  const [jumpNodesIndices, setJumpNodesIndices] = useState([]);

  // State to determine whether the file was changed through a jump
  const [doPositionJump, setDoPositionJump] = useState(false);

  // The position to jump to on a new file load
  const [jumpPosition, setJumpPosition] = useState(new monaco.Position(0, 0));

  // Reference to the editor container
  const editorContainerRef = useRef(null);

  // Monaco editor instance
  const [editor, setEditor] = useState(null);

  // Java file content to display
  const [javaFileContent, setJavaFileContent] = useState("");

  // We'll build a line->traceId map (actually an array of traceIds) after we have editor + jsonManager
  const lineToTraceIdRef = useRef({});

  /** Loads text from `displayedFile` into state. */
  const loadJavaFile = async () => {
    try {
      if (displayedFile) {
        const text = await displayedFile.text();
        setJavaFileContent(text);
      }
    } catch (error) {
      console.error("Error loading the Java file:", error);
    }
  };

  // ---------------------------------- Decorators (highlighting) ----------------------------------

  function highlightActive(range) {
    editor.createDecorationsCollection([
      {
        options: { className: "active" },
        range: {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn,
        },
      },
    ]);
  }

  function highlightLink(range, linkOrOutLink) {
    editor.createDecorationsCollection([
      {
        options: { className: "link" },
        range: {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn,
        },
      },
    ]);
    setNodeSymbol(range, linkOrOutLink);
  }

  function highlightLoop(range) {
    editor.createDecorationsCollection([
      {
        options: { className: "loop" },
        range: {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn,
        },
      },
    ]);
    setNodeSymbol(range, "loop");
  }

  function highlightEnd(range) {
    editor.createDecorationsCollection([
      {
        options: { className: "inactive" },
        range: {
          startLineNumber: range.startLineNumber,
          startColumn: range.startColumn,
          endLineNumber: range.endLineNumber,
          endColumn: range.endColumn,
        },
      },
    ]);
  }

  // Places an icon in the margin
  function setNodeSymbol(range, symbol) {
    const widgetRight = {
      domNode: (function () {
        const domNode = document.createElement("img");
        if (symbol === "loop") {
          domNode.src = loopImage;
        } else if (symbol === "link") {
          domNode.src = linkImage;
        } else {
          domNode.src = outlinkImage;
        }
        return domNode;
      })(),

      getId() {
        return range.toString();
      },

      getDomNode() {
        return this.domNode;
      },

      getPosition() {
        return {
          lane: monaco.editor.GlyphMarginLane.Right,
          range: {
            startLineNumber: range.startLineNumber,
            startColumn: 1,
            endLineNumber: range.startLineNumber,
            endColumn: 1,
          },
        };
      },
    };

    editor.addGlyphMarginWidget(widgetRight);
    editor.layoutGlyphMarginWidget(widgetRight);
  }

  // Draw a vertical line next to executed code
  function placeLinePiece(startLineNumber, symbol) {
    editor.createDecorationsCollection([
      {
        range: new monaco.Range(startLineNumber, 1, startLineNumber, 1),
        options: {
          glyphMarginClassName: symbol,
        },
      },
    ]);
  }

  function iterateLine(range) {
    return new monaco.Range(
      range.startLineNumber + 1,
      0,
      range.endLineNumber + 1,
      0
    );
  }

  function drawLine(ranges) {
    let ongoing = false;
    for (let i = 0; i < ranges.length; i++) {
      if (
        i + 1 < ranges.length &&
        ranges[i].startLineNumber === ranges[i + 1].startLineNumber
      ) {
        continue;
      }

      let startLine = new monaco.Range(
        ranges[i].startLineNumber,
        0,
        ranges[i].startLineNumber + 1,
        0
      );
      let endLine = iterateLine(startLine);

      while (endLine.startLineNumber < ranges[i].endLineNumber) {
        placeLinePiece(endLine.startLineNumber, "line");
        endLine = iterateLine(endLine);
      }

      placeLinePiece(
        startLine.startLineNumber,
        ongoing ? "line" : "start"
      );

      startLine = new monaco.Range(
        ranges[i].endLineNumber,
        0,
        ranges[i].endLineNumber + 1,
        0
      );
      endLine = iterateLine(startLine);

      if (i !== ranges.length - 1) {
        while (
          editor.getModel().getValueInRange(endLine).trim().length === 0 &&
          endLine.startLineNumber < ranges[i + 1].startLineNumber
        ) {
          endLine = iterateLine(endLine);
        }
      }

      if (
        i + 1 < ranges.length &&
        endLine.startLineNumber === ranges[i + 1].startLineNumber
      ) {
        if (startLine.startLineNumber === ranges[i].startLineNumber) {
          startLine = iterateLine(startLine);
        }
        while (startLine.startLineNumber < endLine.startLineNumber) {
          placeLinePiece(startLine.startLineNumber, "line");
          startLine = iterateLine(startLine);
        }
        ongoing = true;
      } else {
        placeLinePiece(
          ranges[i].endLineNumber,
          ongoing ? "end" : "one-line"
        );
        ongoing = false;
      }
    }
  }

  // -------------------- Handling iteration changes --------------------

  function changeIteration(newIterationIndex) {
    // your existing logic

   setActiveIterationIndices([newIterationIndex]);
  }

  // --------------- Handling clicks to jump among nodes ---------------

  function handleJumps() {
    editor.onMouseDown((e) => {
      if (!e.target || !e.target.position) {
        return;
      }
      const position = e.target.position;
      jumpNodesIndices.forEach((jumpIndex) => {
        if (jumpIndex === 1) return;
        const jump = jsonManager.nodes[jumpIndex];
        if (jump.nodeType !== "Function" || jumpIndex === activeFunctionIndex) {
          if (jump.nodeType === "Function" && jump.outLinks.length === 2) {
            if (jump.outLinks[1].range.containsPosition(position)) {
              setJumpPosition(jump.outLinkPosition);
              setDoPositionJump(true);
              setActiveIterationIndices(jump.outLoopIterations);
              setActiveFunctionIndex(jump.outFunctionIndex);
            }

            jsonManager
              .updateActiveRangesFunction(activeFunctionIndex, activeIterationIndices)
              .forEach((range) => {
                if (
                  range.containsRange(jsonManager.nodes[jumpIndex].outLinks[0].range)
                ) {
                  if (jump.outLinks[0].range.containsPosition(position)) {
                    setJumpPosition(jump.outLinkPosition);
                    setDoPositionJump(true);
                    setActiveIterationIndices(jump.outLoopIterations);
                    setActiveFunctionIndex(jump.outFunctionIndex);
                  }
                }
              });
          } else {
            jump.outLinks.forEach((outLink) => {
              if (outLink.range.containsPosition(position)) {
                setJumpPosition(jump.outLinkPosition);
                setDoPositionJump(true);
                setActiveIterationIndices(jump.outLoopIterations);
                setActiveFunctionIndex(jump.outFunctionIndex);
              }
            });
          }
        }
        // skip link for current function if same file
        if (jumpIndex === activeFunctionIndex) {
          return;
        }
        if (jump.nodeType === "Function") {
          if (jump.link.range.containsPosition(position)) {
            setJumpPosition(jump.linkPosition);
            setDoPositionJump(true);
            setActiveIterationIndices(jsonManager.initIterations(jumpIndex, []));
            setActiveFunctionIndex(jumpIndex);
          }
        }
      });
    });
  }

  /** Handle clicks on loop lines to change iteration. */
// In EditorManager, inside handleIterationButton:
function handleIterationButton() {
  editor.onMouseDown((e) => {
    if (!e.target || !e.target.position) return;

    const position = e.target.position;

    activeIterationIndices.forEach((iterationIndex) => {
      const iteration = jsonManager.nodes[iterationIndex];
      if (iteration.link.range.containsPosition(position)) {
        const baseId = JsonManager.getBaseTraceId(iteration.traceId);
        let nextIteration = prompt("Please enter the iteration", iteration.iteration);
        nextIteration = parseInt(nextIteration, 10);
        for (let i = 0; i < jsonManager.nodes.length; i++) {
          const node = jsonManager.nodes[i];
          const candidateBaseId = JsonManager.getBaseTraceId(node.traceId);
          if (
            candidateBaseId === baseId &&
            node.iteration === nextIteration &&
            node.parentIndex === iteration.parentIndex
          ) {
            changeIteration(i);
            break;
          }
        }
      }
    });
  });
}


  function splitRangeByLine(range) {
    if (!editor) return [range];
    // fallback if editor is null

    const result = [];
    const model = editor.getModel();
    if (!model) return [range];

    const startLineNumber = range.startLineNumber;
    const endLineNumber = range.endLineNumber;

    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      // find the first non-whitespace character
      const firstNonWhitespace = lineContent.search(/\S/);
      const startColumn =
        lineNumber === startLineNumber
          ? range.startColumn
          : Math.max(1, firstNonWhitespace + 1);
      const endColumn =
        lineNumber === endLineNumber
          ? range.endColumn
          : model.getLineMaxColumn(lineNumber);

      result.push(
        new monaco.Range(lineNumber, startColumn, lineNumber, endColumn)
      );
    }
    return result;
  }

  /** Reveal a position in the editor */
  function jumpToPosition(position) {
    if (!position || !editor) return;
    editor.revealLineNearTop(position.lineNumber);
    editor.setPosition(position);
  }

  // --------------- useEffect for traceNodeToHighlight ---------------
  useEffect(() => {
    if (traceNodeToHighlight && editor) {
      if (traceNodeToHighlight.link && traceNodeToHighlight.link.range) {
        jumpToPosition(traceNodeToHighlight.link.range.getStartPosition());
        highlightActive(traceNodeToHighlight.link.range);
      }
      // optionally: setTraceNodeToHighlight(null);
    }
  }, [traceNodeToHighlight, editor]);

  // --------------- onMouseMove subscription ---------------
useEffect(() => {
  if (editor) {
    const subscription = editor.onMouseMove((e) => {
      if (!e.target || !e.target.position) {
        onHoverTraceId && onHoverTraceId(null);
        return;
      }
      const line = e.target.position.lineNumber;
      const traceIds = lineToTraceIdRef.current[line];

      // CHANGE #1: Remove "&& activeIterationIndices.length > 0"
      // so ANY lines with traceIds are highlighted, not just loop/iteration lines
      if (Array.isArray(traceIds) && traceIds.length > 0) {
        // Keep your existing logic: pick the "active iteration" if present
        // or fall back to the first trace ID
        if (activeIterationIndices.length > 0) {
          const activeIterIndex = activeIterationIndices[0];
          const activeIterNode = jsonManager.nodes[activeIterIndex];
          if (!activeIterNode) {
            onHoverTraceId && onHoverTraceId(traceIds[0]);
            return;
          }
          const activeTraceId = activeIterNode.traceId;

          if (traceIds.includes(activeTraceId)) {
            onHoverTraceId && onHoverTraceId(activeTraceId);
          } else {
            onHoverTraceId && onHoverTraceId(traceIds[0]);
          }
        } else {
          // If no active iteration, just highlight the first trace ID
          onHoverTraceId && onHoverTraceId(traceIds[0]);
        }
      } else {
        onHoverTraceId && onHoverTraceId(null);
      }
    });
    return () => subscription.dispose();
  }
}, [editor, onHoverTraceId, activeIterationIndices, jsonManager]);

  // --------------- Initialize the main function + file ---------------
  useEffect(() => {
    if (jsonManager) {
      setActiveFunctionIndex(jsonManager.getMain());
      // pick node #1’s file if that’s your main approach
      setActiveAndDisplayed(jsonManager.nodes[1].link.file);
      setActiveIterationIndices(jsonManager.initIterations(1, []));
    }
  }, [jsonManager]);

  // --------------- Load the displayed file content ---------------
  useEffect(() => {
    if (displayedFile) {
      loadJavaFile();
    }
  }, [displayedFile]);

  // --------------- Initialize / re-init the editor ---------------
  useEffect(() => {
    let newEditor;
    if (javaFileContent && editorContainerRef.current) {
      // Build hints for iteration labels
      let hints = [];
      if (isActiveDisplayed()) {
        activeIterationIndices.forEach((iterationIndex) => {
          const position = jsonManager.nodes[iterationIndex].link.range.getStartPosition();
          const content =
            "(" +
            jsonManager.nodes[iterationIndex].iteration +
            "/" +
            jsonManager.getLastIterationNumber(iterationIndex) +
            ")";
          hints.push({ position, content });
        });
      }

      // If there's an existing editor, dispose it before re-creating
      if (editor) {
        editor.dispose();
      }
      newEditor = EditorInitializer.initializeEditor(
        editorContainerRef,
        javaFileContent,
        hints
      );
      if (newEditor) {
        setEditor(newEditor.editor);
      }
    }
    // Cleanup
    return () => {
      if (javaFileContent && editorContainerRef.current && newEditor) {
        newEditor.dispose();
      }
    };
  }, [javaFileContent, activeIterationIndices, activeFunctionIndex]);

  // --------------- Update file display if active function changes ---------------
  useEffect(() => {
    if (jsonManager) {
      setActiveAndDisplayed(jsonManager.nodes[activeFunctionIndex].link.file);
    }
  }, [activeFunctionIndex]);

  // --------------- Update jump-nodes if iteration changes ---------------
  useEffect(() => {
    if (jsonManager) {
      setJumpNodesIndices(
        jsonManager.updateJumpsFunction(activeFunctionIndex, activeIterationIndices)
      );
    }
  }, [activeIterationIndices]);

  // --------------- When editor updates, highlight active ranges ---------------
  useEffect(() => {
    if (jsonManager && editor) {
      const rangesToHighlight = jsonManager.updateActiveRangesFunction(
        activeFunctionIndex,
        activeIterationIndices
      );

      if (isActiveDisplayed()) {
        setDoPositionJump(true);
        rangesToHighlight.forEach((rangeToHighlight) => {
          // split each range by line
          splitRangeByLine(rangeToHighlight).forEach((splitRangeToHighlight) => {
            highlightActive(splitRangeToHighlight);
          });
        });
        // draw lines next to those ranges
        drawLine(rangesToHighlight);

        // highlight jump links
        jumpNodesIndices.forEach((jumpIndex) => {
          const jNode = jsonManager.nodes[jumpIndex];
          if (
            jNode.nodeType !== "Function" ||
            jumpIndex === activeFunctionIndex
          ) {
            if (
              jNode.nodeType === "Function" &&
              jNode.outLinks.length === 2
            ) {
              highlightLink(jNode.outLinks[1].range);
              jsonManager
                .updateActiveRangesFunction(activeFunctionIndex, activeIterationIndices)
                .forEach((range) => {
                  if (range.containsRange(jNode.outLinks[0].range)) {
                    highlightLink(jNode.outLinks[0].range, "outlink");
                  }
                });
            } else {
              jNode.outLinks.forEach((outLink) => {
                highlightLink(outLink.range, "outlink");
              });
            }
          }
          // If not current function, highlight the function link
          if (jumpIndex !== activeFunctionIndex && jNode.nodeType === "Function") {
            highlightLink(jNode.link.range, "link");
          }
        });

        handleJumps();
        handleIterationButton();

        // highlight loops
        activeIterationIndices.forEach((index) => {
          highlightLoop(jsonManager.nodes[index].link.range);
        });
      }

      // Position the editor to the active node or do the saved jump
      if (!doPositionJump && isActiveDisplayed()) {
        if (activeFunctionIndex !== 1) {
          jumpToPosition(
            jsonManager.nodes[activeFunctionIndex].outLinks[
              jsonManager.nodes[activeFunctionIndex].outLinks.length - 1
            ].range.getStartPosition()
          );
        } else {
          jumpToPosition(
            jsonManager.nodes[activeFunctionIndex].link.range.getStartPosition()
          );
        }
        setDoPositionJump(false);
      }
      if (doPositionJump) {
        setDoPositionJump(false);
        jumpToPosition(jumpPosition);
      }
    }
  }, [editor]);

  // --------------- Build line->traceIds map ---------------
  useEffect(() => {
    if (!jsonManager || !jsonManager.nodes) {
      return;
    }
    lineToTraceIdRef.current = {};

    jsonManager.nodes.forEach((node, idx) => {
      if (!node.traceId) return;
      if (!node.ranges || node.ranges.length === 0) return;

      node.ranges.forEach((rng) => {
        const startLine = rng.startLineNumber;
        const endLine = rng.endLineNumber;
        for (let ln = startLine; ln <= endLine; ln++) {
          // store an array of all traceIds for that line
          if (!lineToTraceIdRef.current[ln]) {
            lineToTraceIdRef.current[ln] = [];
          }
          lineToTraceIdRef.current[ln].push(node.traceId);
        }
      });
    });

    console.log("Built line->traceId map:", lineToTraceIdRef.current);
  }, [jsonManager]);

  // ------------------------- Render -------------------------

  return (
    <main className="right-container">
      <div ref={editorContainerRef} className="editor-container"></div>
    </main>
  );
}

EditorManager.propTypes = {
  displayedFile: PropTypes.instanceOf(File),
  setActiveAndDisplayed: PropTypes.func,
  activeFunctionIndex: PropTypes.number,
  setActiveFunctionIndex: PropTypes.func,
  traceNodeToHighlight: PropTypes.object,
  setTraceNodeToHighlight: PropTypes.func,
  onHoverTraceId: PropTypes.func,
  isActiveDisplayed: PropTypes.func,
  jsonManager: PropTypes.instanceOf(JsonManager),
  activeIterationIndices: PropTypes.array.isRequired,  // new prop
  setActiveIterationIndices: PropTypes.func.isRequired,  // new prop

};

export default EditorManager;import TraceNode from "./TraceNode";
import { editor, Position } from "monaco-editor";

/**
 * Helper function to extract the base trace ID from a full traceId.
 * If the traceId contains "_iter", this function returns only the part before it.
 * Otherwise, it returns the entire traceId.
 * @param {string} traceId
 * @returns {string}
 */
/**
 * Returns the substring before "_iter".
 * If no "_iter" is found, returns the entire traceId.
 *
 * @param {string} traceId e.g. "loop42_iter3" or "loop42"
 * @returns {string} the base ID, e.g. "loop42"
 */

/**
 * Class that contains an array of {@link TraceNode}s and manages them.
 * It provides functions to extract information needed for the editor.
 */
class JsonManager {
  /**
   * Constructor takes in a JSON string, maps the data to {@link TraceNode}s,
   * and saves them in an array.
   * @param {string} jsonString - JSON data from the backend.
   */
  constructor(jsonString) {
    this.nodes = [];
    this.activeIterations = [];
    this.skipIds = [];
    this.activeIterationIndex = 0;
    let data = jsonString;
    data.forEach((jsonData) => {
      this.nodes.push(new TraceNode(jsonData));
    });
    for (let i = 2; i < this.nodes.length; i++) {
      let node = this.nodes[i];
      if (node.nodeType === "Throw") {
        node.outLinkPosition = new Position(0, 0);
        if (this.nodes[node.outIndex].ranges.length !== 0) {
          // If catch is empty and has no range, pick the first sorted range.
          node.outLinkPosition = this.nodes[node.outIndex].ranges
            .sort((a, b) =>
              a.startLineNumber < b.startLineNumber ? -1 : a.startLineNumber > b.startLineNumber ? 1 : 0
            )[0].getStartPosition();
        }
      }
      if (node.nodeType === "Function") {
        node.linkPosition = node.outLinks[node.outLinks.length - 1].range.getStartPosition();
        node.outLinkPosition = node.link.range.getStartPosition();
      }
      if (node.nodeType === "Function" || node.nodeType === "Throw") {
        let currentIndex = node.outIndex;
        let currentNode = this.nodes[currentIndex];
        let parentBeforeIndex = -1;
        let parentBeforeTraceId = -1;
        let iterationsBefore = [];
        let iterations = [];
        let start = true;
        while (currentNode.nodeType !== "Function" || start) {
          if (!start) {
            currentIndex = this.nodes[currentIndex].parentIndex;
            currentNode = this.nodes[currentIndex];
            parentBeforeTraceId = this.nodes[parentBeforeIndex].traceId;
          }
          iterations = [];
          if (currentNode.nodeType === "Loop") {
            iterations.push(currentIndex);
          }
          currentNode.childrenIndices.forEach((childIndex) => {
            if (childIndex === parentBeforeIndex) {
              iterations.push(...iterationsBefore);
            } else if (this.nodes[childIndex].iteration === 1 &&
                       this.nodes[childIndex].traceId !== parentBeforeTraceId) {
              iterations.push(childIndex);
            }
          });
          parentBeforeIndex = currentIndex;
          iterationsBefore = iterations;
          start = false;
        }
        this.nodes[i].outLoopIterations = iterations;
        this.nodes[i].outFunctionIndex = currentIndex;
      }
    }
  }

  /**
   * Returns the index of the main function in nodes.
   * @returns {number}
   */
  getMain() {
    return 1;
  }

  /**
   * Returns the parent function index for a given node.
   * @param {number} nodeIndex
   * @returns {number}
   */
  getParentFunction(nodeIndex) {
    if (nodeIndex < 1 || nodeIndex > this.nodes.length - 1) return -1;
    let currentIndex = nodeIndex;
    let currentNode = this.nodes[currentIndex];
    while (currentNode.nodeType !== "Function") {
      currentIndex = currentNode.parentIndex;
      currentNode = this.nodes[currentIndex];
    }
    return currentIndex;
  }

  /**
     * Returns the base trace ID by stripping out the "_iter" suffix.
     * @param {string} traceId
     * @returns {string} the base trace ID.
     */
    static getBaseTraceId(traceId) {
      const index = traceId.indexOf("_iter");
      return index === -1 ? traceId : traceId.substring(0, index);
    }


  /**
   * Returns the number of the last iteration that belongs to the loop.
   * This method compares only the base trace IDs (before "_iter").
   * @param {number} iterationIndex - Index of a TraceNode representing one iteration.
   * @returns {number} The highest iteration number found.
   */
getLastIterationNumber(iterationIndex) {
  let iterationIndexId = this.nodes[iterationIndex].traceId;
  // Use the static method on JsonManager
  let baseId = JsonManager.getBaseTraceId(iterationIndexId);
  let lastIteration = this.nodes[iterationIndex].iteration;

  this.nodes[this.nodes[iterationIndex].parentIndex].childrenIndices.forEach((childIndex) => {
    if (
      JsonManager.getBaseTraceId(this.nodes[childIndex].traceId) === baseId &&
      this.nodes[childIndex].iteration > lastIteration
    ) {
      lastIteration = this.nodes[childIndex].iteration;
    }
  });
  return lastIteration;
}

  /**
   * Determines the initially active iterations for a function.
   * @param {number} functionIndex - Index of the currently active function.
   * @param {Array} activeIterationIndices - Current active iteration indices.
   * @returns {Array} An array with the active iteration node indices.
   */
  initIterations(functionIndex, activeIterationIndices) {
    this.skipIds = [];
    this.activeIterations = [...activeIterationIndices];
    this.activeIterationIndex = 0;
    this.nodes[functionIndex].childrenIndices.forEach((childIndex) => {
      this.getIterations(childIndex);
    });
    return this.activeIterations;
  }

  /**
   * Recursively determines all active loops that have this node as a grandparent.
   * @param {number} nodeIndex - Current node index.
   * @returns {Array} An array with the active iteration indices.
   */
  getIterations(nodeIndex) {
    let end = false;
    this.skipIds.forEach((skipId) => {
      if (this.nodes[nodeIndex].traceId === skipId) {
        end = true;
      }
    });
    if (end || this.nodes[nodeIndex].nodeType === "Function") {
      return [];
    }
    let skip = true;
    if (this.nodes[nodeIndex].nodeType !== "Loop") skip = false;
    if (this.activeIterationIndex + 1 > this.activeIterations.length && this.nodes[nodeIndex].iteration === 1) {
      this.activeIterations.push(nodeIndex);
      this.activeIterationIndex++;
      skip = false;
      this.skipIds.push(this.nodes[nodeIndex].traceId);
    }
    if (
      !(this.activeIterationIndex + 1 > this.activeIterations.length) &&
      this.nodes[nodeIndex].iteration === this.nodes[this.activeIterations[this.activeIterationIndex]].iteration
    ) {
      this.activeIterationIndex++;
      this.skipIds.push(this.nodes[nodeIndex].traceId);
      skip = false;
    }
    if (!skip) {
      this.nodes[nodeIndex].childrenIndices.forEach((childIndex) => {
        this.activeIterations.concat(this.getIterations(childIndex));
      });
    }
  }

  /**
   * Determines all function and throw nodes in the currently active function,
   * marking whether they are active based on the active iterations.
   * @param {number} functionIndex - Index of the active function.
   * @param {Array} activeIterationIndices - Current active loop iterations.
   * @returns {Array} An array with indices of the function or throw nodes.
   */
  updateJumpsFunction(functionIndex, activeIterationIndices) {
    this.skipIds = [];
    this.activeIterations = [...activeIterationIndices];
    let jumps = [];
    jumps.push(functionIndex);
    this.nodes[functionIndex].childrenIndices.forEach((childIndex) => {
      jumps = jumps.concat(this.getJumps(childIndex));
    });
    return jumps;
  }

  /**
   * Recursively determines all function and throw nodes that are part of the current function.
   * @param {number} nodeIndex - Current node index.
   * @returns {Array} An array with indices of the function or throw nodes.
   */
  getJumps(nodeIndex) {
    let jumps = [];
    let end = false;
    this.skipIds.forEach((skipId) => {
      if (this.nodes[nodeIndex].traceId === skipId) end = true;
    });
    if (end) return jumps;
    if (this.nodes[nodeIndex].nodeType === "Function" || this.nodes[nodeIndex].nodeType === "Throw")
      jumps.push(nodeIndex);
    if (
      (!(this.nodes[nodeIndex].nodeType === "Loop") ||
        nodeIndex === this.activeIterations[0])
    ) {
      if (this.nodes[nodeIndex].nodeType === "Loop") {
        this.activeIterations.shift();
        this.skipIds.push(this.nodes[nodeIndex].traceId);
      }
      if (this.nodes[nodeIndex].nodeType !== "Function") {
        this.nodes[nodeIndex].childrenIndices.forEach((childIndex) => {
          jumps = jumps.concat(this.getJumps(childIndex));
        });
      }
    }
    return jumps;
  }

  /**
   * Determines all active ranges in the currently active function.
   * @param {number} functionIndex - Index of the active function.
   * @param {Array} activeIterationIndices - Active loop iterations.
   * @returns {Array} An array with all active ranges.
   */
  updateActiveRangesFunction(functionIndex, activeIterationIndices) {
    let ranges = [];
    this.activeIterations = [...activeIterationIndices];
    this.skipIds = [];
    this.nodes[functionIndex].ranges.forEach((range) => {
      ranges.push(range);
    });
    this.nodes[functionIndex].childrenIndices.forEach((childIndex) => {
      ranges = ranges.concat(this.getActiveRanges(childIndex));
    });
    ranges.sort((a, b) =>
      a.startLineNumber < b.startLineNumber ? -1 : a.startLineNumber > b.startLineNumber ? 1 : 0
    );
    return ranges;
  }

  /**
   * Recursively determines all ranges of all child nodes that are part of the current function.
   * @param {number} nodeIndex - Current node index.
   * @returns {Array} An array with the ranges for the node and its children.
   */
  getActiveRanges(nodeIndex) {
    let ranges = [];
    let end = false;
    this.skipIds.forEach((skipId) => {
      if (this.nodes[nodeIndex].traceId === skipId) end = true;
    });
    if (end) return ranges;
    if (this.nodes[nodeIndex].nodeType === "Function") {
      ranges.push(this.nodes[nodeIndex].link.range);
    } else if (
      this.nodes[nodeIndex].nodeType !== "Loop" ||
      nodeIndex === this.activeIterations[0]
    ) {
      if (this.nodes[nodeIndex].nodeType === "Loop") {
        this.activeIterations.shift();
        this.skipIds.push(this.nodes[nodeIndex].traceId);
      }
      this.nodes[nodeIndex].ranges.forEach((range) => {
        ranges.push(range);
      });
      this.nodes[nodeIndex].childrenIndices.forEach((childIndex) => {
        ranges = ranges.concat(this.getActiveRanges(childIndex));
      });
    }
    return ranges;
  }
}

export default JsonManager;
/**
 * TracNode class that stores the information of a traced node from tha backend.
 * ranges: Array of all executed {@link monaco.Range}s contained in this node.
 * childrenIndices: Array of all children indices associated with this node.
 * parentIndex: Index of the parent of this node. Null for root node.
 *      For Loop iterations always set to node of first iteration.
 * link: {@link SourceRange} that contains {@link monaco.Range} of link that can be clicked
 *      and relative filepath it leads to. Only set for Function and Loop nodes, otherwise null.
 *      For main function set range is set to method head and file that contains it.
 * outLinks: Array of maximum two {@link SourceRange}s. For Functions function name and if there taken return statement.
 *      For Throws one {@link SourceRange} with range of throw statement. Null for main function.
 * outIndex: Index of parent node the outLink leads back to.
 * iteration: Number of the iteration. Set for Loops otherwise null.
 * c
 * Loop iterations of the same loop have the same traceId.
 * nodeType: String set to "Loop", "Function", "Throw" or "Other"
 *  The following attributes are initially set to null,
 *  but after creation of all TraceNodes assigned in {@link JsonManager},
 *  because they partly depend on other TraceNodes.
 * linkPosition: {@link monaco.Position} the link leads to.
 * outLinkPosition: {@link monaco.Position} both outLinks leads to.
 * outFunctionIndex: Index of the function that contains the node that both outLinks lead to.
 * outLoopIterations: Iterations that are set in the outFunction were the node both outLinks lead to got executed.
 */
class TraceNode {
    /**
     * Maps given json data from the backend onto an instance of this class and extend it with additional information.
     * @param node json data node.
     */
    constructor(node) {
        //ranges: Array of all executed {@link monaco.Range}s contained in this node.

        this.ranges = [];
        if (node.ranges !== undefined)
            node.ranges.forEach((range) => {
                this.ranges.push(new monaco.Range(
                    range.begin.line, range.begin.column, range.end.line, range.end.column + 1));
            });

        //childrenIndices: Array of all children indices associated with this node.
        this.childrenIndices = [];
        if (node.childrenIndices !== undefined)
            node.childrenIndices.forEach((childIndex) => {
                this.childrenIndices.push(childIndex);
            });
        //parentIndex: Index of the parent of this node. Null for root node.
        //      For Loop iterations always set to node of first iteration.
        this.parentIndex = null;
        if (node.parentIndex !== undefined)
            this.parentIndex = node.parentIndex;

        //link: {@link SourceRange} that contains {@link monaco.Range} of link that can be clicked
        //      and relative filepath it leads to. Only set for Function and Loop nodes, otherwise null.
        //      For main function set range is set to method head and file that contains it.
        this.link = null;
        if (node.link !== undefined)
            this.link = new SourceRange(
                new monaco.Range(
                    node.link.begin.line,
                    node.link.begin.column,
                    node.link.end.line,
                    node.link.end.column + 1),
                node.link.filepath);

        //outLinks: Array of maximum two {@link SourceRange}s. For Functions function name and if there taken return statement.
        //      For Throws one {@link SourceRange} with range of throw statement. Null for main function.
        this.outLinks = [];
        if (node.outLinks !== undefined)
            node.outLinks.forEach((nodeOutLink) => {
                this.outLinks.push(new SourceRange(
                    new monaco.Range(
                        nodeOutLink.begin.line,
                        nodeOutLink.begin.column,
                        nodeOutLink.end.line,
                        nodeOutLink.end.column + 1),
                    nodeOutLink.filepath));
            });

        //outIndex: Index of parent node the outLink leads back to.
        this.outIndex = null;
        if (node.outIndex !== undefined && node.outIndex !== 0)
            this.outIndex = node.outIndex;

        //iteration: Number of the iteration. Set for Loops otherwise null.
        this.iteration = null;
        if (node.iteration !== undefined)
            this.iteration = node.iteration;

        //traceId: Unique id that can be used to map each TraceNode to its code block.
        //      Loop iterations of the same loop have the same traceId.
        this.traceId = null;
if (node.traceId !== undefined) {
  // Overwrite 'this.traceId' to always store the iteration-based ID
  if (this.iteration != null && this.iteration > 0) {
    this.traceId = node.traceId + "_iter" + this.iteration;
  } else {
    this.traceId = node.traceId;
  }
} else {
  this.traceId = null;
}
        //nodeType: String set to "Loop", "Function", "Throw" or "Other"
        this.nodeType = "Other";
        if (this.iteration != null) {
            this.nodeType = "Loop";
        } else if (this.link != null) {
            this.nodeType = "Function";
        } else if (this.outIndex != null) {
            this.nodeType = "Throw";
        }
         this.nodeMethodName = node.nodeMethodName || null;
        //----The following attributes are initially set to null.----
        //  After creation of all TraceNodes assigned in {@link JsonManager},
        //  because they partly depend on other TraceNodes.

        //linkPosition: {@link monaco.Position} the link leads to.
        this.linkPosition = null;
        //outLinkPosition: {@link monaco.Position} both outLinks leads to.
        this.outLinkPosition = null;
        //outFunctionIndex: Index of the function that contains the node that both outLinks lead to.
        this.outFunctionIndex = null;
        //outLoopIterations: Iterations that are set in the outFunction were the node both outLinks lead to got executed.
        this.outLoopIterations = [];
    }
}

export default TraceNode;

/**
 * Container that links a monaco.Range and a relative file path together. Used for links.
 */
class SourceRange {
    /**
     * Creates an instance of this class.
     * @param range monaco.Range.
     * @param filepath string of a relative file path.
     */
    constructor(range, filepath) {
        this.range = range;
        this.file = filepath;
    }
}
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';

/**
 * Initializes the Monaco Editor with specific settings for editing Java files.
 * This class provides static methods to configure the editor, including setting
 * up the theme, syntax highlighting, and adjusting the editor's height based on its content.
 * It also demonstrates how to use Monaco Editor's API to create a more interactive
 * and user-friendly code editor environment.
 */
export class EditorInitializer {

    /**
     * Initializes the Monaco Editor in the provided container with the given Java file content.
     * This method sets up the editor with predefined options such as language, theme, and various
     * editor behaviors like word wrapping and automatic layout adjustments. It also defines a custom
     * theme and syntax highlighting rules specifically tailored for Java code.
     *
     * @param containerRef A reference to the container DOM element where the editor will be instantiated.
     * @param javaFileContent The initial Java code content to be loaded into the editor.
     * @param hints list of InlayHints(monaco editor) to display in the editor.
     * @return The initialized Monaco Editor instance, or undefined if initialization fails.
     */
    static initializeEditor(containerRef, javaFileContent, hints) {
        if (typeof javaFileContent !== 'string') {
            console.error('javaFileContent must be a string');
            return;
        }
        if (!containerRef.current) {
            return;
        }
        const editor = monaco.editor.create(containerRef.current, {  // Creates a new editor
            value: javaFileContent,
            language: 'java',
            theme: 'java-theme',
            glyphMargin: true,
            scrollBeyondLastLine: false,
            minimap: {enabled: false},
            wordWrap: 'off',
            readOnly: true,
            automaticLayout: true,
            scrollbar: {
                alwaysConsumeMouseWheel: true
            },
        });

        // ----------------------------------Syntax Highlighting ------------------------------------


        monaco.editor.defineTheme('java-theme', {  // Style Properties of the editor
            base: 'vs-dark',
            inherit: true,
            rules: [
                {token: 'keyword', foreground: '569CD6', fontStyle: 'bold'},
                {token: 'number', foreground: 'B5CEA8'},
                {token: 'type', foreground: '4EC9B0'},
                {token: 'string', foreground: 'CE9178'},
                {token: 'comment', foreground: '6A9955'},
                {token: 'annotation', foreground: 'B8860B'},
                {token: 'operator', foreground: 'D4D4D4'},
                {token: 'delimiter', foreground: 'D4D4D4'},
                {token: 'namespace', foreground: '4EC9B0'},
                {token: 'custom-system-out', foreground: 'FFA500'},
                {token: 'custom-wrapper-class', foreground: 'FF4500'},
                {token: 'custom-exception-class', foreground: 'FF0000'},
            ],
            colors: {
                'editor.foreground': '#D4D4D4',
                'editor.background': '#1E1E1E',
                'editorCursor.foreground': '#A7A7A7',
                'editor.lineHighlightBackground': '#2D2D30',
                'editorLineNumber.foreground': '#858585',
                'editor.selectionBackground': '#264F78',
                'editor.inactiveSelectionBackground': '#3A3D41',
            }
        });

        monaco.languages.setMonarchTokensProvider('java', {   // Syntax highlighting
            tokenizer: {
                root: [
                    [/\b(Integer|Double|Float|Long|Short|Byte|Boolean|Character|String)\b/, 'custom-wrapper-class'],
                    [/\b(Exception|RuntimeException|Error|Throwable|IOException|NullPointerException|ArrayIndexOutOfBoundsException|ClassCastException|NumberFormatException)\b/, 'custom-exception-class'],
                    [/\bSystem\.out\.[a-zA-Z]+\b/, 'custom-system-out'],
                    [/public|private|protected/, 'keyword'],
                    [/\b(class|interface|enum|extends|implements|volatile|synchronized|abstract|final|static|void|boolean|byte|char|short|int|float|long|double)\b/, 'keyword'],
                    [/\b(package|import)\b/, 'keyword'],
                    [/\b(return|if|else|while|for|break|continue|do|switch|case|default)\b/, 'keyword'],
                    [/\b(try|catch|finally|throw|throws)\b/, 'keyword'],
                    [/\b(new|this|super)\b/, 'keyword'],
                    [/\b(instanceof)\b/, 'keyword'],
                    [/\b(true|false|null)\b/, 'literal'],
                    [/\b(System\.out\.println)\b/, 'custom-function'],
                    [/\b([A-Za-z_]\w*)\b/, 'identifier'],
                    [/"([^"\\]|\\.)*"/, 'string'],
                    [/'([^'\\]|\\.)*'/, 'string'],
                    [/\b\d+\.?\d*\b/, 'number'],
                    [/\/\/.*$/, 'comment'],
                    [/\/\*/, {token: 'comment', next: '@comment'}],
                    [/[[\](){}<>]/, 'delimiter'],
                    [/[;,.]/, 'delimiter'],
                    [/[+\-*/=<>!&|~^%]/, 'operator']
                ],
                comment: [
                    [/[^/*]+/, 'comment'],
                    [/\*\//, 'comment', '@pop'],
                    [/[/*]/, 'comment']
                ],
            }
        });

        // ----------------------------------Loop Indices ------------------------------------
        const {dispose} = monaco.languages.registerInlayHintsProvider("java", {
            provideInlayHints(model, range, token) {
                let newHints = [];
                hints.forEach((hint) => {
                    newHints.push({
                        kind: monaco.languages.InlayHintKind.Parameter,
                        position: {column: hint.position.column, lineNumber: hint.position.lineNumber},
                        label: hint.content,
                    });
                });
                return {
                    hints: newHints,
                    dispose: () => {
                    },
                };
            },
        });

        //Sets up a monaco worker environment (uses the default provided by monaco).
        window.MonacoEnvironment = {
            getWorkerUrl: function (moduleId, label) {
                return `data:text/javascript;charset=utf-8,${encodeURIComponent(`
            self.MonacoEnvironment = {
                baseUrl: ''
            };

            self.onmessage = function (e) {
                // Handle message received from the main thread
            };
        `)}`;
            }
        };

        monaco.languages.register({id: 'java'});   // Activates the syntax highlighting

        // -------------------------------------  All other function calls for the editor  ----------------------------

        // Update the content
        editor.getModel().setValue(javaFileContent);

        // Set dark theme
        monaco.editor.setTheme('vs-dark');

        return {editor, dispose};
    }
}

export default EditorInitializer;import React, { useState } from "react";
import DirectoryBar from "./WebsiteElements/DirectoryBar";
import EditorManager from "./Editor/EditorManager";
import JsonManager from "./Editor/JsonManager";
import ModularActions from "./ModularActions";
import JsonViewer from "./WebsiteElements/JsonViewer";
import TraceTree from "./WebsiteElements/TraceTree";
import MethodTreeView from "./WebsiteElements/MethodTreeView";
import "./Css/App.css";

function WebsiteContainer() {
  // Basic states for file management, JSON data and visualization
  const [displayedFile, setDisplayedFile] = useState(null);
  const [activeFile, setActiveFile] = useState(null);
  const [jsonManager, setJsonManager] = useState(null);
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [visualizationJson, setVisualizationJson] = useState(null);
  const [staticMethodsJson, setStaticMethodsJson] = useState(null);
  const [activeFunctionIndex, setActiveFunctionIndex] = useState(1);
  const [viewerMode, setViewerMode] = useState("JSON");
  const [traceNodeToHighlight, setTraceNodeToHighlight] = useState(null);
  const [hoveredTraceId, setHoveredTraceId] = useState(null);
  const [activeIterationIndices, setActiveIterationIndices] = useState([]);

  // Additional states for JBMC integration
  const [jbmcJson, setJbmcJson] = useState(null);
  const [instrumentId, setInstrumentId] = useState("");

  /** Sets both 'displayedFile' and 'activeFile' to the file that matches the given path. */
  function setActiveAndDisplayed(path) {
    uploadedFiles.forEach((uploadedFile) => {
      if (path === uploadedFile.webkitRelativePath) {
        setDisplayedFile(uploadedFile);
        setActiveFile(uploadedFile);
      }
    });
  }

  /** Displays the current active file in the editor (if any). */
  function setDisplayedToActive() {
    setDisplayedFile(activeFile);
  }

  /** Checks if the file currently displayed is the same as the 'active' file. */
  function isActiveDisplayed() {
    return activeFile && displayedFile ? activeFile === displayedFile : false;
  }

  /**
   * Receives the files from the folder upload (DirectoryBar), optionally uploads them
   * to the server, and stores them.
   */
  async function passOnUploadedFiles(files) {
    setUploadedFiles(files);
    // Optionally upload files to the server.
    await fetch("/api/upload", {
      method: "POST",
      body: new FormData(document.getElementById("upload-form")),
    });
  }

  /** Called when the user clicks a trace node in TraceTree to highlight in the editor. */
  function highlightTraceNodeInEditor(node) {
    console.log("highlightTraceNodeInEditor called with node:", node);
    setTraceNodeToHighlight(node);
  }

  /** Called from EditorManager when the user hovers code to highlight in the TraceTree. */
  function handleHoverTraceId(traceId) {
    console.log("WebsiteContainer: hovered trace ID in editor =>", traceId);
    setHoveredTraceId(traceId);
  }

  /** Fetches static methods JSON from the backend. */
  async function fetchStaticMethods() {
    try {
      const response = await fetch("/api/static-methods");
      const data = await response.json();
      setStaticMethodsJson(data);
    } catch (error) {
      console.error("Error fetching static methods:", error);
    }
  }

  /** Fetch JBMC result for a given instrument ID and switch the viewer to JBMC mode. */
  async function handleFetchJBMC() {
    if (!instrumentId) {
      alert("Please enter instrument ID");
      return;
    }
    try {
      const resp = await fetch(`/api/jbmc/result/${instrumentId}`);
      if (!resp.ok) {
        const err = await resp.text();
        throw new Error(err);
      }
      const data = await resp.json();
      setJbmcJson(data);
      setViewerMode("JBMC"); // Switch UI to display JBMC JSON
    } catch (error) {
      console.error("Error fetching JBMC result:", error);
      alert("Could not fetch JBMC JSON: " + error.message);
    }
  }

  console.log("[WebsiteContainer] viewerMode =", viewerMode);
  console.log("[WebsiteContainer] jsonManager =", jsonManager);
  console.log("[WebsiteContainer] visualizationJson =", visualizationJson);

  return (
    <div className="content">
      {/* LEFT COLUMN: Directory */}
      <div className="left-container">
        <DirectoryBar
          setDisplayedFile={setDisplayedFile}
          setDisplayedToActive={setDisplayedToActive}
          passOnUploadedFiles={passOnUploadedFiles}
          passOnJsonData={(jsonData) => {
            console.log("[WebsiteContainer] JSON from DirectoryBar:", jsonData);
            setJsonManager(new JsonManager(jsonData));
          }}
        />
      </div>

      {/* MIDDLE COLUMN: JBMC Section, Modular Actions and JSON Viewer */}
      <div className="middle-container">
        {/* JBMC Section */}
        <div className="jbmc-section" style={{ margin: "10px" }}>
          <div>
            <button onClick={() => setViewerMode("JSON")}>
              Show Normal JSON
            </button>
            <button onClick={() => setViewerMode("JBMC")}>
              Show JBMC JSON
            </button>
            <input
              placeholder="Instrument ID"
              value={instrumentId}
              onChange={(e) => setInstrumentId(e.target.value)}
            />
            <button onClick={handleFetchJBMC}>Fetch JBMC Output</button>
          </div>
          {viewerMode === "JBMC" && jbmcJson && (
            <JsonViewer
              jsonData={jbmcJson}
              onElementClick={(updated) =>
                console.log("JBMC JSON clicked:", updated)
              }
            />
          )}
        </div>

        {/* Modular Actions Section */}
        <div className="modular-actions-section">
          <ModularActions
            projectName="MyProject"
            setJsonManager={(newManager) => {
              console.log("[WebsiteContainer] setJsonManager called:", newManager);
              setJsonManager(newManager);
            }}
            onVisualize={(json) => {
              console.log("[WebsiteContainer] onVisualize - got JSON:", json);
              setVisualizationJson(json);
            }}
            uploadedFiles={uploadedFiles}
          />
        </div>

        {/* JSON Viewer Section with Tab Buttons */}
        <div className="json-viewer-section">
          <div style={{ display: "flex", gap: "10px", margin: "10px" }}>
            <button onClick={() => setViewerMode("JSON")}>JSON</button>
            <button onClick={() => setViewerMode("METHOD")}>Methods</button>
            <button onClick={() => setViewerMode("TRACE")}>Trace</button>
            <button
              onClick={() => {
                setViewerMode("STATIC");
                fetchStaticMethods();
              }}
            >
              Static Methods
            </button>
          </div>

          {viewerMode === "JSON" && visualizationJson && (
            <JsonViewer
              jsonData={visualizationJson}
              onElementClick={(updated) =>
                console.log("JSON updated/clicked:", updated)
              }
            />
          )}

          {viewerMode === "METHOD" && jsonManager && (
            <MethodTreeView
              jsonManager={jsonManager}
              onSelectMethod={(nodeIndex) => {
                if (!jsonManager || !jsonManager.nodes[nodeIndex]) return;
                const methodNode = jsonManager.nodes[nodeIndex];
                if (methodNode.link && methodNode.link.file) {
                  setActiveAndDisplayed(methodNode.link.file);
                }
                setActiveFunctionIndex(nodeIndex);
                console.log("User picked methodNode #", nodeIndex, methodNode);
                const initIters = jsonManager.initIterations(nodeIndex, []);
                setActiveIterationIndices(initIters);
              }}
              className="method-view-section"
            />
          )}

          {viewerMode === "TRACE" && jsonManager && (
            <TraceTree
              nodes={jsonManager.nodes}
              onSelectTraceNode={(node) => {
                if (node.link && node.link.file) {
                  setActiveAndDisplayed(node.link.file);
                }
                highlightTraceNodeInEditor(node);
              }}
              hoveredTraceId={hoveredTraceId}
            />
          )}

          {viewerMode === "STATIC" && staticMethodsJson && (
            <JsonViewer
              jsonData={staticMethodsJson}
              onElementClick={(updated) =>
                console.log("Static methods JSON updated/clicked:", updated)
              }
            />
          )}
        </div>
      </div>

      {/* RIGHT COLUMN: Editor */}
      <div className="right-container">
        <EditorManager
          displayedFile={displayedFile}
          setActiveAndDisplayed={setActiveAndDisplayed}
          isActiveDisplayed={isActiveDisplayed}
          jsonManager={jsonManager}
          activeFunctionIndex={activeFunctionIndex}
          setActiveFunctionIndex={setActiveFunctionIndex}
          traceNodeToHighlight={traceNodeToHighlight}
          setTraceNodeToHighlight={setTraceNodeToHighlight}
          onHoverTraceId={handleHoverTraceId}
          activeIterationIndices={activeIterationIndices}
          setActiveIterationIndices={setActiveIterationIndices}
        />
      </div>
    </div>
  );
}

export default WebsiteContainer;
